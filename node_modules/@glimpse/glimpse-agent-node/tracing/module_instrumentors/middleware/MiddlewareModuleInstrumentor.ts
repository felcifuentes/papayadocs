import { IModuleInstrumentor } from '../../IModuleInstrumentor';
import { IModuleInfo } from '../../IModuleInfo';
import { IEnableInstrumentationResult } from '../../IEnableInstrumentationResult';
import { MiddlewareWrapper } from '../../../inspectors/util/MiddlewareWrapper';

export abstract class MiddlewareModuleInstrumentor implements IModuleInstrumentor {
    private _supportedModules: { [ moduleName: string]: string; };

    constructor(
        supportedModule: string,
        supportedModuleVersions: string,
        private name: string,
        private displayName: string,
        private packageName: string) {
        this._supportedModules = {
            [supportedModule]: supportedModuleVersions
        };
    }

    public get supportedModules(): { [ moduleName: string ]: string; } {
        return this._supportedModules;
    }

    public enableInstrumentation(moduleInfo: IModuleInfo): IEnableInstrumentationResult {

        const newModule = this.proxyModule(moduleInfo.originalModule);

        // Right now we don't do any in-depth checking to see if the module couldn't
        // be enabled for some reason, so we hard return true here
        return {
            isEnabled: true,
            newModule
        };
    }

    protected onProxyModule(originalModule, newModule) {
        // No-op.
    }

    private proxyModule(originalModule) {
        const self = this;

        function newModule(...moduleArgs) {
            const middleware = originalModule.call(this, ...moduleArgs);

            MiddlewareWrapper.attachMetadata(middleware, self.name, self.displayName, self.packageName);

            return middleware;
        }

        this.onProxyModule(originalModule, newModule);

        return newModule;
    }
}

export default MiddlewareModuleInstrumentor;
