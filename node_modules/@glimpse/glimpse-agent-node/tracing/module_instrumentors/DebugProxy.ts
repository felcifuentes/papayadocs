import * as semver from 'semver';

import { IAgentBroker } from '../../messaging/IAgentBroker';
import IConsoleManager from '../../configuration/IConsoleManager';
import { IContextManager } from '../../messaging/IContextManager';
import { IMessageConverter } from '../../messaging/IMessageConverter';
import { IStackFrame, IStackHelper } from '../../inspectors/util/StackHelper';

export interface IFunctionModule {
    (...args);
}

interface ILogWritePayload {
    message: string | any[]; // tslint:disable-line:no-any
    level: string;
    library: string;
    category: string;
    tokenSupport?: string;
}

interface ILogWriteTokenPrintfPayload extends ILogWritePayload {
    tokenSupport: 'node' | 'browser';
}

interface ICallStackPayload {
    frames?: IStackFrame[];
}

/**
 * A proxy for the [`debug`](https://www.npmjs.com/package/debug) package.
 */
export class DebugProxy {
    constructor(
        private broker: IAgentBroker,
        private consoleManager: IConsoleManager,
        private contextManager: IContextManager,
        private messageConverter: IMessageConverter,
        private stackHelper: IStackHelper) {
    }

    /**
     * Proxies an instance of the `debug` module.
     *
     * @param originalModule The original `debug` module to proxy.
     * @param version The version of the module to proxy.
     * @return A proxied module.
     */
    public proxyModule<T extends IFunctionModule>(originalModule: T, version: string): T {
        const self = this;

        function newModule(name: string, ...moduleArgs) {
            const originalFunction = originalModule.call(this, name, ...moduleArgs);

            function newFunction(...messageArgs) {
                const newFunctionSelf = this;

                function callOriginalFunction() {
                    return originalFunction.call(newFunctionSelf, ...messageArgs);
                };

                // Only publish Glimpse messages if we're in a valid context, and this logger is enabled...
                // tslint:disable-next-line:no-any
                if (self.contextManager.isWithinContext() && (<any>newFunction).enabled) {
                    // NOTE: Because the logger may be redirecting logs to the `console`, we suppress its 
                    //       (Glimpse) output when deferring to it.
                    const result = self.consoleManager.callWithMessageSuppression(callOriginalFunction);

                    // NOTE: We must publish *after* the debug message is written due to versions prior to 2.4.0 
                    //       deferring setting color-related options until the first write.
                    self.publish(name, newModule, version, newFunction, messageArgs);

                    return result;
                }

                return callOriginalFunction();
            };

            // NOTE: The `debug` function is a function with a number of properties attached.
            //       The module caches and directly uses a reference to the original function
            //       (rather than, say, use the `this` parameter of calls made to it). This
            //       means that we can't simply copy the properties over to the proxy function.
            //       Instead, we have to create a "pass through" proxy that proxies every
            //       property. In this case, we also have to create proxies for properties that
            //       are not set by default.

            const additionalProperties = ['log'];

            if (semver.satisfies(version, '<2.4')) {
                additionalProperties.push('useColors', 'color');
            }

            self.proxyObject(newFunction, originalFunction, additionalProperties);

            return newFunction;
        };

        // NOTE: The `debug` module is a function with a number of properties attached.
        //       The module caches and directly uses a reference to the original function
        //       (rather than, say, use the `this` parameter of calls made to it). This
        //       means that we can't simply copy the properties over to the proxy function.
        //       Instead, we have to create a "pass through" proxy that proxies every
        //       property.
        self.proxyObject(newModule, originalModule);

        return <T>newModule;
    }

    private proxyObject(newObject, originalObject, additionalProperties?: string[]) {
        for (let property in originalObject) {
            if (originalObject.hasOwnProperty(property)) {
                this.proxyProperty(newObject, originalObject, property);
            }
        }

        if (additionalProperties) {
            additionalProperties.forEach(property => this.proxyProperty(newObject, originalObject, property));
        }
    }

    private proxyProperty(newObject, originalObject, property: string) {
        Object.defineProperty(newObject, property, {
            get: function () {
                return originalObject[property];
            },
            set: function(value) {
                originalObject[property] = value;
            }
        });
    }

    private publish(name: string, module, version: string, stackTopFunction, messageArgs) {
        const modifiedArgs = [...messageArgs];

        if (modifiedArgs.length) {
            // Replicate `debug` "coercion" of the first, possibly Error object...
            modifiedArgs[0] = module.coerce(modifiedArgs[0]);

            // Replicate `debug` shifting of arguments when passed an initial object... 
            if (typeof modifiedArgs[0] !== 'string') {
                // NOTE: %O was (properly) added with 2.4.0; previously %o was used.
                modifiedArgs.unshift(semver.satisfies(version, '>=2.4') ? '%O' : '%o');
            }
        }

        // Replicate `debug` application of custom formatters...
        this.applyCustomFormatters(module.formatters, modifiedArgs, stackTopFunction, version);

        // NOTE: Because stack frame mapping is asynchronous, we create the message envelope early to preserve sequential log write ordering.
        const messageEnvelope = this.messageConverter.createMessageEnvelope<ILogWriteTokenPrintfPayload & ICallStackPayload>(
            ['log-write', 'log-token-printf', 'call-stack'],
            /* indices: */ undefined,
            this.contextManager.currentContext());

        this.stackHelper.mapFrames(
            this.stackHelper.captureStack(stackTopFunction),
            mappedFrames => {
                messageEnvelope.payload = {
                    category: name,
                    frames: mappedFrames,
                    level: 'Debug',
                    library: 'debug',
                    message: modifiedArgs,
                    tokenSupport: 'node'
                };

                const transformedMessage = this.messageConverter.transformMessageForTransit(messageEnvelope, messageEnvelope.payload);

                this.broker.sendMessage(transformedMessage);
            });
    }

    private applyCustomFormatters(formatters: { [key: string]: (value) => string }, messageArgs, debugFunction, version: string) {
        if (formatters) {
            let currentArgumentIndex = 0;
            const formatString: string = messageArgs[0];

            for (let i = 0; i < formatString.length - 1; i++) {
                if (formatString[i] === '%') {
                    const format = formatString[i + 1];

                    if (format !== '%') {
                        currentArgumentIndex++;

                        // NOTE: Prior to 2.4.0, `debug` failed to apply uppercase formatters.

                        if (currentArgumentIndex < messageArgs.length
                            && (format === format.toLowerCase() || semver.satisfies(version, '>=2.4'))) {
                            const formatter = formatters[format];

                            if (typeof formatter === 'function') {
                                const formattedArg = formatter.call(debugFunction, messageArgs[currentArgumentIndex]);

                                // Replace the `%x` format with `%s`, and the original argument with its string-formatted version...
                                // NOTE: This differs from what `debug` does, but ensures that the Glimpse Client still shows the
                                //       argument as having been tokenized.
                                messageArgs[0] = this.replaceAt(formatString, i + 1, 's');
                                messageArgs[currentArgumentIndex] = formattedArg;
                            }
                        }
                    }

                    i++;
                }
            }
        }

        return messageArgs;
    }

    private replaceAt(originalString: string, index: number, character: string): string {
        return originalString.substring(0, index) + character + originalString.substr(index + 1);
    }
}

export default DebugProxy;
