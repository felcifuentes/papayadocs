import { v1 as generateUUID } from 'uuid';
import { ClientRequest, IncomingMessage } from 'http';
import { NodeVersionHelper } from '@glimpse/glimpse-common';

import tracing from '../Tracing';
import {
    EVENT_HTTP_CLIENT_REQUEST_CREATED, IClientRequestCreatedEvent,
    EVENT_HTTP_CLIENT_REQUEST_DATA_SENT, IClientRequestDataSentEvent,
    EVENT_HTTP_CLIENT_REQUEST_END, IClientRequestEndEvent,
    EVENT_HTTP_CLIENT_REQUEST_CLOSE, IClientRequestCloseEvent,
    EVENT_HTTP_CLIENT_REQUEST_ERROR, IClientRequestErrorEvent,
    EVENT_HTTP_CLIENT_RESPONSE_RECEIVED, IClientResponseReceivedEvent,
    EVENT_HTTP_CLIENT_RESPONSE_DATA_RECEIVED, IClientResponseDataReceivedEvent,
    EVENT_HTTP_CLIENT_RESPONSE_ABORTED, IClientResponseAbortedEvent,
    EVENT_HTTP_CLIENT_RESPONSE_END, IClientResponseEndEvent,
    EVENT_HTTP_CLIENT_RESPONSE_ERROR, IClientResponseErrorEvent
} from './HttpEvents';
import { IModuleInfo } from '../IModuleInfo';

export class HttpClientProxy {

    private proxiedModules = [];

    // Helper methods for publishing events. We break these out into separate
    // methods so we can enforce type checking for the event interfaces

    private publishRequestCreatedEvent(data: IClientRequestCreatedEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_REQUEST_CREATED, data);
    }

    private publishRequestDataSentEvent(data: IClientRequestDataSentEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_REQUEST_DATA_SENT, data);
    }

    private publishRequestEndEvent(data: IClientRequestEndEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_REQUEST_END, data);
    }

    private publishRequestCloseEvent(data: IClientRequestCloseEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_REQUEST_CLOSE, data);
    }

    private publishRequestErrorEvent(data: IClientRequestErrorEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_REQUEST_ERROR, data);
    }

    private publishResponseReceivedEvent(data: IClientResponseReceivedEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_RESPONSE_RECEIVED, data);
    }

    private publishResponseDataReceivedEvent(data: IClientResponseDataReceivedEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_RESPONSE_DATA_RECEIVED, data);
    }

    private publishResponseAbortedEvent(data: IClientResponseAbortedEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_RESPONSE_ABORTED, data);
    }

    private publishResponseEndEvent(data: IClientResponseEndEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_RESPONSE_END, data);
    }

    private publishResponseErrorEvent(data: IClientResponseErrorEvent): void {
        tracing.publish(EVENT_HTTP_CLIENT_RESPONSE_ERROR, data);
    }

    private patchRequest(httpModule) {
        const self = this;
        const originalRequest = httpModule.request;

        httpModule.request = function glimpseHttpRequest(options, listener, ...requestArgs) {
            let req: ClientRequest;
            const id = generateUUID();
            let isListenerWrapped = false;

            function wrapListener(originalListener) {
                if (isListenerWrapped) {
                    return originalListener;
                }

                isListenerWrapped = true;

                return function glimpseOnResponse(res: IncomingMessage, ...onResponseArgs) {
                    if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_RESPONSE_RECEIVED)) {
                        self.publishResponseReceivedEvent({ id, req, res });
                    }

                    // Patch `push()` in order to capture response bodies as they are "pushed" into the response stream.
                    //
                    // NOTE: Listening to the `data` event has the side effect of Node switching the stream to "flowing",
                    //       where the event will be raised as quickly as possible until the data is exhausted (at which 
                    //       point the `end` event will be raised). Some applications instead use a pull model via
                    //       repeated calls to `read()`, typically in response to the `readable` event. To prevent subtly
                    //       changing the application behavior, Glimpse does not listen to `data` but waits for data to
                    //       be placed into (rather than pulled out from) the response stream.
                    const originalPush = res.push;
                    res.push = function glimpseClientResponsePush(chunk, ...pushArgs) {
                        const result = originalPush.call(this, chunk, ...pushArgs);

                        if (chunk && chunk.length && tracing.isEventEnabled(EVENT_HTTP_CLIENT_RESPONSE_DATA_RECEIVED)) {
                            self.publishResponseDataReceivedEvent({ id, req, res, chunk });
                        }

                        return result;
                    };

                    // NOTE: The `aborted` event is emitted (among other reasons) when data has not been consumed (as expected).
                    res.on('aborted', () => {
                        if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_RESPONSE_ABORTED)) {
                            self.publishResponseAbortedEvent({ id, req, res });
                        }
                    });

                    // NOTE: The `end` event is typically emitted when all response data has been consumed. 
                    res.on('end', () => {
                        if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_RESPONSE_END)) {
                            self.publishResponseEndEvent({ id, req, res });
                        }
                    });

                    res.on('error', (error) => {
                        if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_RESPONSE_ERROR)) {
                            self.publishResponseErrorEvent({ id, req, res, error });
                        }
                    });

                    originalListener.call(this, res, ...onResponseArgs);
                };
            }

            // If a `response` event listener was passed to `request()`, wrap it with our logic...
            if (typeof listener === 'function') {
                listener = wrapListener(listener);
            }

            req = originalRequest.call(this, options, listener, ...requestArgs);

            if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_REQUEST_CREATED)) {
                self.publishRequestCreatedEvent({ id, req, options });
            }

            // Patch `on()` in order to trap listeners for `response`...
            //
            // NOTE: Listening for `response` events has the side effect of Node streaming the response
            //       as well as an expectation by Node that the listener consumes the response data, 
            //       whereas not listening will cause Node to reject the response. Glimpse cannot simply
            //       listen for the `response` event without subtly changing the behavior of the original
            //       application.  Hence, Glimpse instead waits for the application to listen to the event
            //       (or not).
            const originalOn = req.on;
            req.on = function glimpseRequestOn(eventName: string, onListener, ...onArgs) {
                // If a `response` event listener is being added, wrap it with our logic...
                if (eventName === 'response') {
                    onListener = wrapListener(onListener);
                }

                return originalOn.call(this, eventName, onListener, ...onArgs);
            };

            req.on('close', () => {
                if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_REQUEST_CLOSE)) {
                    self.publishRequestCloseEvent({ id, req });
                }
            });

            req.on('error', (error) => {
                if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_REQUEST_ERROR)) {
                    self.publishRequestErrorEvent({ id, req, error });
                }
            });

            // Note: it's possible to write data using the `end` method as well,
            // but that method calls `write` under the hood, and patching both
            // leads to a doubly patched write method, which duplicates the body
            const oldWrite = req.write;
            req.write = function(chunk, ...writeArgs) {
                const result = oldWrite.call(this, chunk, ...writeArgs);
                if ((typeof chunk === 'string' || Buffer.isBuffer(chunk)) &&
                    tracing.isEventEnabled(EVENT_HTTP_CLIENT_REQUEST_DATA_SENT)
                ) {
                    self.publishRequestDataSentEvent({ id, req, chunk });
                }
                return result;
            };

            const oldEnd = req.end;
            req.end = function end(...endArgs) {
                const result = oldEnd.apply(this, endArgs);
                if (tracing.isEventEnabled(EVENT_HTTP_CLIENT_REQUEST_END)) {
                    self.publishRequestEndEvent({ id, req });
                }
                return result;
            };

            return req;
        };
    }

    private patchGet(httpModule) {
        // NOTE: Starting with Node 8, http.get() no longer defers to http.request() but
        //       instead directly invokes the internal request(). Because it also calls
        //       req.end() (which we need to patch as well), simply patching http.get() 
        //       is not sufficient.  Instead, we replicate the (old) behavior of http.get().
        if (NodeVersionHelper.getMajor() >= 8) {
            httpModule.get = function glimpseHttpGet(...getArgs) {
                const req = httpModule.request.call(this, ...getArgs);

                req.end();

                return req;
            };
        }
    }

    public init(moduleInfo: IModuleInfo) {
        const httpModule = moduleInfo.originalModule;
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);

        this.patchRequest(httpModule);
        this.patchGet(httpModule);
    }
}
