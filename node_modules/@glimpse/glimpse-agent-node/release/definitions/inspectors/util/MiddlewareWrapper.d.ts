/// <reference types="node" />
import { IAgentBroker } from '../../messaging/IAgentBroker';
import { IContextManager } from '../../messaging/IContextManager';
import { IDateTime } from '../../configuration/IDateTime';
import { IStackHelper, IStackFrame } from './StackHelper';
import { IMessageConverter } from '../../messaging/IMessageConverter';
import * as http from 'http';
export interface IMiddlewareStartPayload {
    correlationId: string;
    name: string;
    displayName?: string;
    packageName?: string;
    paths?: string[];
    method?: string;
    params?: {
        [key: string]: string;
    };
    startTime: string;
    frames: IStackFrame[];
}
export interface IMiddlewareHeaderOperation {
    op: string;
    name: string;
    value?: string[];
}
export interface IMiddlewareOperation {
    type: string;
}
export interface IResponseBodyOperation extends IMiddlewareOperation {
}
export interface IResponseStatusCodeOperation extends IMiddlewareOperation {
    statusCode: number;
}
export interface IMiddlewareEndPayload {
    correlationId: string;
    name: string;
    displayName?: string;
    packageName?: string;
    paths?: string[];
    method?: string;
    params?: {
        [key: string]: string;
    };
    endTime: string;
    duration: number;
    headers?: IMiddlewareHeaderOperation[];
    operations?: IMiddlewareOperation[];
    result: string;
}
export interface IMiddlewareNextCallback {
    (result?: string | Error): any;
}
export interface IMiddlewareMetadata {
    ignore?: boolean;
    name?: string;
    displayName?: string;
    packageName?: string;
}
export interface IMiddlewareFunction {
    (req?: http.IncomingMessage, res?: http.ServerResponse, next?: IMiddlewareNextCallback): any;
    name?: string;
    glimpse?: IMiddlewareMetadata;
}
export interface IMiddlewareErrorFunction {
    (err: any, req?: http.IncomingMessage, res?: http.ServerResponse, next?: IMiddlewareNextCallback): any;
    name?: string;
    glimpse?: IMiddlewareMetadata;
}
export interface IMiddlewareFunctionContext {
    originalName?: string;
}
export interface IWrappedMiddlewareFunction {
    name?: string;
    /**
     * A reference to the original (now wrapped) middleware.
     *
     * LoopBack (http://loopback.io/) requires being able to find registered middleware within the Express route layers.
     * In Glimpse wrapping the middleware and instead registering its wrapped version, LoopBack can no longer find it.
     * However, LoopBack will search through all (own) properties of the registered middleware, looking for a match to
     * the original middleware, in case it's been wrapped by a monitoring application (like Glimpse).
     */
    __glimpse_original?: any;
    glimpse?: IMiddlewareFunctionContext;
}
export interface IExpressRequest extends http.IncomingMessage {
    params?: {
        [key: string]: string;
    };
}
export declare class MiddlewareWrapper {
    private stackHelper;
    private messageConverter;
    private broker;
    private contextManager;
    private dateTime;
    constructor(stackHelper: IStackHelper, messageConverter: IMessageConverter, broker: IAgentBroker, contextManager: IContextManager, dateTime: IDateTime);
    private mapFramesAndSendMessageAsync(message);
    private wrapCommonMiddleware(paths, method, originalMiddlewareName, middlewareMetadata, req, res, next, originalMiddleware, registrationCallstack);
    private wrapErrorMiddleware(paths, method, originalMiddleware, registrationCallstack);
    private wrapMiddleware(paths, method, originalMiddleware, registrationCallstack);
    wrap(paths: string[], method: string, originalMiddleware: IMiddlewareFunction | IMiddlewareErrorFunction, registrationCallstack: IStackFrame[]): IMiddlewareFunction | IMiddlewareErrorFunction;
    static attachMetadata(middleware: IMiddlewareFunction, name: string, displayName: string, packageName: string): void;
}
