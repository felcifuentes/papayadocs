"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var uuid_1 = require("uuid");
var glimpse_common_1 = require("@glimpse/glimpse-common");
var Tracing_1 = require("../Tracing");
var HttpEvents_1 = require("./HttpEvents");
var HttpClientProxy = (function () {
    function HttpClientProxy() {
        this.proxiedModules = [];
    }
    // Helper methods for publishing events. We break these out into separate
    // methods so we can enforce type checking for the event interfaces
    HttpClientProxy.prototype.publishRequestCreatedEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_CREATED, data);
    };
    HttpClientProxy.prototype.publishRequestDataSentEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_DATA_SENT, data);
    };
    HttpClientProxy.prototype.publishRequestEndEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_END, data);
    };
    HttpClientProxy.prototype.publishRequestCloseEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_CLOSE, data);
    };
    HttpClientProxy.prototype.publishRequestErrorEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_ERROR, data);
    };
    HttpClientProxy.prototype.publishResponseReceivedEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_RECEIVED, data);
    };
    HttpClientProxy.prototype.publishResponseDataReceivedEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_DATA_RECEIVED, data);
    };
    HttpClientProxy.prototype.publishResponseAbortedEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_ABORTED, data);
    };
    HttpClientProxy.prototype.publishResponseEndEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_END, data);
    };
    HttpClientProxy.prototype.publishResponseErrorEvent = function (data) {
        Tracing_1.default.publish(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_ERROR, data);
    };
    HttpClientProxy.prototype.patchRequest = function (httpModule) {
        var self = this;
        var originalRequest = httpModule.request;
        httpModule.request = function glimpseHttpRequest(options, listener) {
            var requestArgs = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                requestArgs[_i - 2] = arguments[_i];
            }
            var req;
            var id = uuid_1.v1();
            var isListenerWrapped = false;
            function wrapListener(originalListener) {
                if (isListenerWrapped) {
                    return originalListener;
                }
                isListenerWrapped = true;
                return function glimpseOnResponse(res) {
                    var onResponseArgs = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        onResponseArgs[_i - 1] = arguments[_i];
                    }
                    if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_RECEIVED)) {
                        self.publishResponseReceivedEvent({ id: id, req: req, res: res });
                    }
                    // Patch `push()` in order to capture response bodies as they are "pushed" into the response stream.
                    //
                    // NOTE: Listening to the `data` event has the side effect of Node switching the stream to "flowing",
                    //       where the event will be raised as quickly as possible until the data is exhausted (at which 
                    //       point the `end` event will be raised). Some applications instead use a pull model via
                    //       repeated calls to `read()`, typically in response to the `readable` event. To prevent subtly
                    //       changing the application behavior, Glimpse does not listen to `data` but waits for data to
                    //       be placed into (rather than pulled out from) the response stream.
                    var originalPush = res.push;
                    res.push = function glimpseClientResponsePush(chunk) {
                        var pushArgs = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            pushArgs[_i - 1] = arguments[_i];
                        }
                        var result = originalPush.call.apply(originalPush, [this, chunk].concat(pushArgs));
                        if (chunk && chunk.length && Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_DATA_RECEIVED)) {
                            self.publishResponseDataReceivedEvent({ id: id, req: req, res: res, chunk: chunk });
                        }
                        return result;
                    };
                    // NOTE: The `aborted` event is emitted (among other reasons) when data has not been consumed (as expected).
                    res.on('aborted', function () {
                        if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_ABORTED)) {
                            self.publishResponseAbortedEvent({ id: id, req: req, res: res });
                        }
                    });
                    // NOTE: The `end` event is typically emitted when all response data has been consumed. 
                    res.on('end', function () {
                        if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_END)) {
                            self.publishResponseEndEvent({ id: id, req: req, res: res });
                        }
                    });
                    res.on('error', function (error) {
                        if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_RESPONSE_ERROR)) {
                            self.publishResponseErrorEvent({ id: id, req: req, res: res, error: error });
                        }
                    });
                    originalListener.call.apply(originalListener, [this, res].concat(onResponseArgs));
                };
            }
            // If a `response` event listener was passed to `request()`, wrap it with our logic...
            if (typeof listener === 'function') {
                listener = wrapListener(listener);
            }
            req = originalRequest.call.apply(originalRequest, [this, options, listener].concat(requestArgs));
            if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_CREATED)) {
                self.publishRequestCreatedEvent({ id: id, req: req, options: options });
            }
            // Patch `on()` in order to trap listeners for `response`...
            //
            // NOTE: Listening for `response` events has the side effect of Node streaming the response
            //       as well as an expectation by Node that the listener consumes the response data, 
            //       whereas not listening will cause Node to reject the response. Glimpse cannot simply
            //       listen for the `response` event without subtly changing the behavior of the original
            //       application.  Hence, Glimpse instead waits for the application to listen to the event
            //       (or not).
            var originalOn = req.on;
            req.on = function glimpseRequestOn(eventName, onListener) {
                var onArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    onArgs[_i - 2] = arguments[_i];
                }
                // If a `response` event listener is being added, wrap it with our logic...
                if (eventName === 'response') {
                    onListener = wrapListener(onListener);
                }
                return originalOn.call.apply(originalOn, [this, eventName, onListener].concat(onArgs));
            };
            req.on('close', function () {
                if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_CLOSE)) {
                    self.publishRequestCloseEvent({ id: id, req: req });
                }
            });
            req.on('error', function (error) {
                if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_ERROR)) {
                    self.publishRequestErrorEvent({ id: id, req: req, error: error });
                }
            });
            // Note: it's possible to write data using the `end` method as well,
            // but that method calls `write` under the hood, and patching both
            // leads to a doubly patched write method, which duplicates the body
            var oldWrite = req.write;
            req.write = function (chunk) {
                var writeArgs = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    writeArgs[_i - 1] = arguments[_i];
                }
                var result = oldWrite.call.apply(oldWrite, [this, chunk].concat(writeArgs));
                if ((typeof chunk === 'string' || Buffer.isBuffer(chunk)) &&
                    Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_DATA_SENT)) {
                    self.publishRequestDataSentEvent({ id: id, req: req, chunk: chunk });
                }
                return result;
            };
            var oldEnd = req.end;
            req.end = function end() {
                var endArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    endArgs[_i] = arguments[_i];
                }
                var result = oldEnd.apply(this, endArgs);
                if (Tracing_1.default.isEventEnabled(HttpEvents_1.EVENT_HTTP_CLIENT_REQUEST_END)) {
                    self.publishRequestEndEvent({ id: id, req: req });
                }
                return result;
            };
            return req;
        };
    };
    HttpClientProxy.prototype.patchGet = function (httpModule) {
        // NOTE: Starting with Node 8, http.get() no longer defers to http.request() but
        //       instead directly invokes the internal request(). Because it also calls
        //       req.end() (which we need to patch as well), simply patching http.get() 
        //       is not sufficient.  Instead, we replicate the (old) behavior of http.get().
        if (glimpse_common_1.NodeVersionHelper.getMajor() >= 8) {
            httpModule.get = function glimpseHttpGet() {
                var getArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    getArgs[_i] = arguments[_i];
                }
                var req = (_a = httpModule.request).call.apply(_a, [this].concat(getArgs));
                req.end();
                return req;
                var _a;
            };
        }
    };
    HttpClientProxy.prototype.init = function (moduleInfo) {
        var httpModule = moduleInfo.originalModule;
        if (this.proxiedModules.indexOf(httpModule) !== -1) {
            throw new Error('Cannot proxy a module that has already been proxied');
        }
        this.proxiedModules.push(httpModule);
        this.patchRequest(httpModule);
        this.patchGet(httpModule);
    };
    return HttpClientProxy;
}());
exports.HttpClientProxy = HttpClientProxy;

//# sourceMappingURL=../../../maps/tracing/module_instrumentors/HttpClientProxy.js.map
