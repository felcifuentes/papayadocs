"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var semver = require("semver");
/**
 * A proxy for the [`debug`](https://www.npmjs.com/package/debug) package.
 */
var DebugProxy = (function () {
    function DebugProxy(broker, consoleManager, contextManager, messageConverter, stackHelper) {
        this.broker = broker;
        this.consoleManager = consoleManager;
        this.contextManager = contextManager;
        this.messageConverter = messageConverter;
        this.stackHelper = stackHelper;
    }
    /**
     * Proxies an instance of the `debug` module.
     *
     * @param originalModule The original `debug` module to proxy.
     * @param version The version of the module to proxy.
     * @return A proxied module.
     */
    DebugProxy.prototype.proxyModule = function (originalModule, version) {
        var self = this;
        function newModule(name) {
            var moduleArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                moduleArgs[_i - 1] = arguments[_i];
            }
            var originalFunction = originalModule.call.apply(originalModule, [this, name].concat(moduleArgs));
            function newFunction() {
                var messageArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    messageArgs[_i] = arguments[_i];
                }
                var newFunctionSelf = this;
                function callOriginalFunction() {
                    return originalFunction.call.apply(originalFunction, [newFunctionSelf].concat(messageArgs));
                }
                ;
                // Only publish Glimpse messages if we're in a valid context, and this logger is enabled...
                // tslint:disable-next-line:no-any
                if (self.contextManager.isWithinContext() && newFunction.enabled) {
                    // NOTE: Because the logger may be redirecting logs to the `console`, we suppress its 
                    //       (Glimpse) output when deferring to it.
                    var result = self.consoleManager.callWithMessageSuppression(callOriginalFunction);
                    // NOTE: We must publish *after* the debug message is written due to versions prior to 2.4.0 
                    //       deferring setting color-related options until the first write.
                    self.publish(name, newModule, version, newFunction, messageArgs);
                    return result;
                }
                return callOriginalFunction();
            }
            ;
            // NOTE: The `debug` function is a function with a number of properties attached.
            //       The module caches and directly uses a reference to the original function
            //       (rather than, say, use the `this` parameter of calls made to it). This
            //       means that we can't simply copy the properties over to the proxy function.
            //       Instead, we have to create a "pass through" proxy that proxies every
            //       property. In this case, we also have to create proxies for properties that
            //       are not set by default.
            var additionalProperties = ['log'];
            if (semver.satisfies(version, '<2.4')) {
                additionalProperties.push('useColors', 'color');
            }
            self.proxyObject(newFunction, originalFunction, additionalProperties);
            return newFunction;
        }
        ;
        // NOTE: The `debug` module is a function with a number of properties attached.
        //       The module caches and directly uses a reference to the original function
        //       (rather than, say, use the `this` parameter of calls made to it). This
        //       means that we can't simply copy the properties over to the proxy function.
        //       Instead, we have to create a "pass through" proxy that proxies every
        //       property.
        self.proxyObject(newModule, originalModule);
        return newModule;
    };
    DebugProxy.prototype.proxyObject = function (newObject, originalObject, additionalProperties) {
        var _this = this;
        for (var property in originalObject) {
            if (originalObject.hasOwnProperty(property)) {
                this.proxyProperty(newObject, originalObject, property);
            }
        }
        if (additionalProperties) {
            additionalProperties.forEach(function (property) { return _this.proxyProperty(newObject, originalObject, property); });
        }
    };
    DebugProxy.prototype.proxyProperty = function (newObject, originalObject, property) {
        Object.defineProperty(newObject, property, {
            get: function () {
                return originalObject[property];
            },
            set: function (value) {
                originalObject[property] = value;
            }
        });
    };
    DebugProxy.prototype.publish = function (name, module, version, stackTopFunction, messageArgs) {
        var _this = this;
        var modifiedArgs = messageArgs.slice();
        if (modifiedArgs.length) {
            // Replicate `debug` "coercion" of the first, possibly Error object...
            modifiedArgs[0] = module.coerce(modifiedArgs[0]);
            // Replicate `debug` shifting of arguments when passed an initial object... 
            if (typeof modifiedArgs[0] !== 'string') {
                // NOTE: %O was (properly) added with 2.4.0; previously %o was used.
                modifiedArgs.unshift(semver.satisfies(version, '>=2.4') ? '%O' : '%o');
            }
        }
        // Replicate `debug` application of custom formatters...
        this.applyCustomFormatters(module.formatters, modifiedArgs, stackTopFunction, version);
        // NOTE: Because stack frame mapping is asynchronous, we create the message envelope early to preserve sequential log write ordering.
        var messageEnvelope = this.messageConverter.createMessageEnvelope(['log-write', 'log-token-printf', 'call-stack'], 
        /* indices: */ undefined, this.contextManager.currentContext());
        this.stackHelper.mapFrames(this.stackHelper.captureStack(stackTopFunction), function (mappedFrames) {
            messageEnvelope.payload = {
                category: name,
                frames: mappedFrames,
                level: 'Debug',
                library: 'debug',
                message: modifiedArgs,
                tokenSupport: 'node'
            };
            var transformedMessage = _this.messageConverter.transformMessageForTransit(messageEnvelope, messageEnvelope.payload);
            _this.broker.sendMessage(transformedMessage);
        });
    };
    DebugProxy.prototype.applyCustomFormatters = function (formatters, messageArgs, debugFunction, version) {
        if (formatters) {
            var currentArgumentIndex = 0;
            var formatString = messageArgs[0];
            for (var i = 0; i < formatString.length - 1; i++) {
                if (formatString[i] === '%') {
                    var format = formatString[i + 1];
                    if (format !== '%') {
                        currentArgumentIndex++;
                        // NOTE: Prior to 2.4.0, `debug` failed to apply uppercase formatters.
                        if (currentArgumentIndex < messageArgs.length
                            && (format === format.toLowerCase() || semver.satisfies(version, '>=2.4'))) {
                            var formatter = formatters[format];
                            if (typeof formatter === 'function') {
                                var formattedArg = formatter.call(debugFunction, messageArgs[currentArgumentIndex]);
                                // Replace the `%x` format with `%s`, and the original argument with its string-formatted version...
                                // NOTE: This differs from what `debug` does, but ensures that the Glimpse Client still shows the
                                //       argument as having been tokenized.
                                messageArgs[0] = this.replaceAt(formatString, i + 1, 's');
                                messageArgs[currentArgumentIndex] = formattedArg;
                            }
                        }
                    }
                    i++;
                }
            }
        }
        return messageArgs;
    };
    DebugProxy.prototype.replaceAt = function (originalString, index, character) {
        return originalString.substring(0, index) + character + originalString.substr(index + 1);
    };
    return DebugProxy;
}());
exports.DebugProxy = DebugProxy;
exports.default = DebugProxy;

//# sourceMappingURL=../../../maps/tracing/module_instrumentors/DebugProxy.js.map
