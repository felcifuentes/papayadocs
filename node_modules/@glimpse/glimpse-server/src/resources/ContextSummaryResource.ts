import { IMessage } from '../messaging/IMessage';
import { IMessageQuery } from '../storage/IMessageQuery';
import { IResource } from './IResource';
import { IServer } from '../IServer';
import { MessageUtilities } from '../messaging/MessageUtilities';

export interface IContextSummaryResourcePayload {
    summary: {
        server: {
            dataStore: {
                totalCount: number;
                totalTime: number;
                listing: {
                    duration: number;
                    operation: string;
                    operationCategory: string;
                }[]
            },
            webServices: {
                totalCount: number;
                totalTime: number;
                listing: {
                    duration: number;
                    url: string;
                    method: string;
                    statusCode: string;
                }[]
            },
            logs: {
                totalErrorCount: number;
                totalWarnCount: number;
                totalInfoCount: number;
            }
        }
    };
}

// TODO: should be replaced with common schema
export interface IDataHttpResponseIndex {
    url: string;
    statusCode: string;
    method: string;
    duration: number;
};
export interface IDataStoreEndIndex {
    operation: string;
    duration: number;
};
export interface ILogWriteIndex {
    level: string;
}
export const agentSourceEnumServer = 'server';
export const dataHttpResponseType = 'data-http-response';
export const dataStoreEndType = 'data-store-end';
export const logWriteType = 'log-write';
export const dataStoreMongodbReadStartType = 'data-store-mongodb-read-start';
export const dataStoreMongodbInsertType = 'data-store-mongodb-insert';
export const dataStoreMongodbDeleteType = 'data-store-mongodb-delete';
export const dataStoreMongodbUpdateType = 'data-store-mongodb-update';
export const dataStoreRedisEndType = 'data-store-redis-end';

const numberToCrudMap = ['Create', 'Read', 'Update', 'Delete'];
const redisCommandToNumberMap = {
    geoadd: 0,
    hmset: 0,
    hset: 0,
    hsetnx: 0,
    linsert: 0,
    lpush: 0,
    lpushx: 0,
    lset: 0,
    mset: 0,
    msetnx: 0,
    psetex: 0,
    rpush: 0,
    rpushx: 0,
    sadd: 0,
    set: 0,
    setbit: 0,
    setex: 0,
    setnx: 0,
    setrange: 0,
    zadd: 0,
    bitcount: 1,
    bitop: 1,
    dbsize: 1,
    dump: 1,
    echo: 1,
    exists: 1,
    geohash: 1,
    geopos: 1,
    geodist: 1,
    georadius: 1,
    georadiusbymember: 1,
    get: 1,
    getbit: 1,
    getrange: 1,
    getset: 1,
    hexists: 1,
    hget: 1,
    hgetall: 1,
    hkeys: 1,
    hlen: 1,
    hmget: 1,
    hstrlen: 1,
    hvals: 1,
    keys: 1,
    lastsave: 1,
    llen: 1,
    lrange: 1,
    mget: 1,
    pttl: 1,
    randomkey: 1,
    scard: 1,
    sdiff: 1,
    sdiffstore: 1,
    sinter: 1,
    sinterstore: 1,
    sismember: 1,
    smembers: 1,
    sort: 1,
    srandmember: 1,
    strlen: 1,
    sunion: 1,
    sunionstore: 1,
    time: 1,
    ttl: 1,
    type: 1,
    zcard: 1,
    zcount: 1,
    zinterstore: 1,
    zlexcount: 1,
    zrange: 1,
    zrangebylex: 1,
    zrevrangebylex: 1,
    zrangebyscore: 1,
    zrank: 1,
    zrevrangebyscore: 1,
    zrevrank: 1,
    zscore: 1,
    zunionstore: 1,
    sscan: 1,
    hscan: 1,
    zscan: 1,
    append: 2,
    decr: 2,
    decrby: 2,
    hincrby: 2,
    hincrbyfloat: 2,
    incr: 2,
    incrby: 2,
    incrbyfloat: 2,
    rename: 2,
    renamenx: 2,
    smove: 2,
    touch: 2,
    zincrby: 2,
    del: 3,
    expire: 3,
    expireat: 3,
    flushall: 3,
    flushdb: 3,
    hdel: 3,
    lpop: 3,
    lrem: 3,
    ltrim: 3,
    pexpire: 3,
    pexpireat: 3,
    rpop: 3,
    rpoplpush: 3,
    spop: 3,
    srem: 3,
    unlink: 3,
    zrem: 3,
    zremrangebylex: 3,
    zremrangebyrank: 3,
    zremrangebyscore: 3
};

const getOperationCategoryStrategy = {
    [dataStoreMongodbReadStartType]: () => 'Read',
    [dataStoreMongodbInsertType]: () => 'Create',
    [dataStoreMongodbDeleteType]: () => 'Delete',
    [dataStoreMongodbUpdateType]: () => 'Update',
    [dataStoreRedisEndType]: (operation) => {
        if (operation !== undefined) {
            operation = operation.toLowerCase();
            if (redisCommandToNumberMap[operation] !== undefined) {
                return numberToCrudMap[redisCommandToNumberMap[operation]];
            }
        }

        return 'Other';
    }
};

function getOperationCategory(types: string[], operation: string) {
    for (let i = 0; i < types.length; i++) {
        const type = types[i];
        if (getOperationCategoryStrategy[type]) {
            return getOperationCategoryStrategy[type](operation);
        }
    }

    return 'Other';
}

function getLevel(level) {
    switch (level.toLowerCase()) {
        case 'critical':
        case 'fatal':
        case 'error':
            return 'Error';
        case 'warn':
        case 'warning':
            return 'Warning';
        case 'information':
        case 'info':
            return 'Info';
        case 'verbose':
        case 'trace':
        case 'silly':
        case 'debug':
            return 'Debug';
        default:
            return 'Log';
    }
}

export class Resource implements IResource {
    private messageQuery: IMessageQuery;

    public constructor(server?: IServer) {
        if (server) {
            this.init(server.providers.messageQuery);
        }
    }

    public init(messageQuery: IMessageQuery) {
        this.messageQuery = messageQuery;
    }

    public name = 'context-summary';
    public uriTemplate = '?contextId={contextId}';
    public templateName = 'contextSummaryTemplate';
    public type = 'client';
    public invoke(req, res) {
        if (!req.query.contextId) {
            res.sendStatus(404);
            res.send('missing contextId parameter');
        } else {
            const messages = this.messageQuery.queryMessages(
                req.query.contextId,
                [ dataHttpResponseType, dataStoreEndType, logWriteType ]
            );

            const payloads: IContextSummaryResourcePayload = {
                summary: {
                    server: {
                        dataStore: {
                            totalCount: 0,
                            totalTime: 0,
                            listing: []
                        },
                        webServices: {
                            totalCount: 0,
                            totalTime: 0,
                            listing: []
                        },
                        logs: {
                            totalErrorCount: 0,
                            totalWarnCount: 0,
                            totalInfoCount: 0
                        }
                    }
                }
            };

            const messageTypeProcessing: { [key: string]: (message: IMessage) => void } = {
                [dataHttpResponseType]: (message: IMessage) => {
                    const index = message.indices as IDataHttpResponseIndex;
                    if (message.agent.source === agentSourceEnumServer
                        && index !== undefined) {
                        const duration = Number(index.duration) || 0;

                        const summary = payloads.summary.server.webServices;
                        summary.totalCount++;
                        summary.totalTime += duration;
                        summary.listing.push({
                            duration,
                            url: index.url,
                            method: index.method,
                            statusCode: index.statusCode
                        });
                    }
                },
                [dataStoreEndType]: (message: IMessage) => {
                    const index = message.indices as IDataStoreEndIndex;
                    // we don't want to process mongodb-read-end messages
                    if (message.agent.source === agentSourceEnumServer
                        && message.types.indexOf('data-store-mongodb-read-end') === -1
                        && index !== undefined) {
                        const duration = Number(index.duration) || 0;

                        const summary = payloads.summary.server.dataStore;
                        summary.totalCount++;
                        summary.totalTime += duration;
                        summary.listing.push({
                            duration,
                            operation: index.operation,
                            operationCategory: getOperationCategory(message.types, index.operation)
                        });
                    }
                },
                [logWriteType]: (message: IMessage) => {
                    const index = message.indices as ILogWriteIndex;
                    if (message.agent.source === agentSourceEnumServer
                        && index !== undefined) {
                        const level = index.level;
                        const levelCategory = getLevel(level);

                        const summary = payloads.summary.server.logs;
                        if (levelCategory === 'Error') {
                            summary.totalErrorCount++;
                        }
                        else if (levelCategory === 'Warning') {
                            summary.totalWarnCount++;
                        }
                        else if (levelCategory === 'Info') {
                            summary.totalInfoCount++;
                        }
                    }
                }
            };

            MessageUtilities.processMessagesForTypes(messages, messageTypeProcessing);

            const stringPayload = JSON.stringify(payloads);

            res.status(200);
            res.type('application/json');
            res.send(stringPayload);
        }
    }
}
