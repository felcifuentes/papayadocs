{"version":3,"sources":["webpack:///agent.js","webpack:///webpack/bootstrap af053e5c570ff6d37255","webpack:///./src/Bootstrap.js","webpack:///./src/Agent.ts","webpack:///./src/MessagePublisher.ts","webpack:///./~/nanoajax/index.js","webpack:///./src/common/GeneralUtilities.ts","webpack:///./src/common/RequestUtilities.ts","webpack:///./src/common/MessageMixins.ts","webpack:///./src/inspectors/XHRInspector.ts","webpack:///./src/common/GlimpseLogger.ts","webpack:///./src/tracing/proxies/XHRProxy.ts","webpack:///./src/tracing/Tracing.ts","webpack:///./src/common/DateTimeUtilities.ts","webpack:///./~/parse-headers/parse-headers.js","webpack:///./~/trim/index.js","webpack:///./~/for-each/index.js","webpack:///./~/is-function/index.js","webpack:///./src/inspectors/HttpRequestUtils.ts","webpack:///./src/common/Constants.ts","webpack:///./src/common/CallStackUtilities.ts","webpack:///./~/error-stack-parser/error-stack-parser.js","webpack:///./~/stackframe/stackframe.js","webpack:///./src/inspectors/FetchInspector.ts","webpack:///./src/tracing/proxies/FetchProxy.ts","webpack:///./src/inspectors/ResourceTimingInspector.ts","webpack:///./src/tracing/proxies/ResourceTimingProxy.ts","webpack:///./src/common/PerformanceUtilities.ts","webpack:///./src/inspectors/NavigationTimingInspector.ts","webpack:///./src/tracing/proxies/NavigationTimingProxy.ts","webpack:///./src/inspectors/ConsoleInspector.ts","webpack:///./src/tracing/proxies/ConsoleProxy.ts","webpack:///./src/inspectors/PerformanceInspector.ts","webpack:///./src/tracing/proxies/PerformanceProxy.ts","webpack:///./src/tracing/initializeProxies.ts"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","window","Symbol","_interopRequireDefault","obj","__esModule","default","_MessagePublisher","_XHRInspector","_FetchInspector","_ResourceTimingInspector","_NavigationTimingInspector","_ConsoleInspector","_PerformanceInspector","_initializeProxies","_initializeProxies2","messagePublisher","MessagePublisher","XHRInspector","init","FetchInspector","ResourceTimingInspector","NavigationTimingInspector","ConsoleInspector","PerformanceInspector","_classCallCheck","instance","Constructor","TypeError","chunkMessages","messageBodies","maxSize","ranges","sum","lastStart","i","length","push","start","end","serializeRanges","payloads","subBodies","slice","payload","join","Object","defineProperty","value","undefined","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_nanoajax","_GeneralUtilities","_RequestUtilities","_MessageMixins","this","ordinal","messageQueue","messageTimeout","type","types","Array","isArray","msg","getGuid","context","getRequestId","agent","source","offset","addOffset","performance","now","message","_this","JSON","stringify","setTimeout","sendData","timeout","publishMessage","createMessage","body","ajax","url","getMessageIngressUrl","method","_this2","maxBodySize","getConfigSettingNumber","bodies","forEach","sendPayload","global","getRequest","cors","XDomainRequest","test","navigator","userAgent","XMLHttpRequest","setDefault","reqfields","params","callback","cb","statusCode","responseText","called","req","status","response","headers","open","success","onload","onreadystatechange","readyState","onerror","ontimeout","onabort","FormData","field","len","setRequestHeader","send","replace","r","Math","random","v","toString","convertBlobToText","blob","encoding","fileReader","FileReader","onloadend","result","readAsText","document","getElementById","getAttribute","getCookie","defaultValue","settings","getConfigSettings","hasOwnProperty","num","parseInt","Number","isNaN","el","val","parse","err","console","error","addEvent","element","eventName","addEventListener","attachEvent","cookie","regexp","RegExp","getHeaderKeys","headerKeys","keys","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","header","name","normalizeHeaders","normalizedHeaders","headerVal","toLowerCase","parseUrl","parser","createElement","href","parsedPort","port","protocol","hostname","pathname","search","hash","stringifyUrl","portSuffix","stringifiedUrl","resolveUrl","urlCache","envelope","addCorrelationBegin","correlationId","addCorrelation","addCorrelationEnd","duration","_typeof","constructor","_GlimpseLogger","_GlimpseLogger2","_XHRProxy","_Tracing","_Tracing2","_DateTimeUtilities","_parseHeaders","_parseHeaders2","_HttpRequestUtils","_CallStackUtilities","initiatorRegExp","requests","contentType","boundary","getMultiPartFormBoundary","_bodyProperty","size","isTruncated","getMaxHTTPBodySize","parts","getMultiPartFormParts","content","Blob","_contentType","createBodyForBlob","bodyProperty","ArrayBuffer","buffer","_bodyProperty2","byteLength","Document","_bodyProperty3","createEmptyBody","_bodyProperty4","_bodyProperty5","_bodyProperty6","event","eventData","data","getStackTrace","frames","createBodyProperty","startTime","getDateTime","Date","timeStamp","identifier","timing","isAjax","requestEntry","tryFindResourceTimingObject","startTimeOffset","timings","responseStart","responseEnd","xhr","getAllResponseHeaders","statusMessage","endTime","_this3","on","EVENT_XHR_REQUEST_SENT","startTimeStamp","before","EVENT_XHR_RESPONSE_RECEIVED","after","EVENT_XHR_ERROR","EVENT_XHR_ABORT","GlimpseLogger","logToConsole","logger","XHRProxy","handleAsyncRequest","requestHeaders","oldXMLHttpRequest","DONE","statusText","bodyType","responseType","publish","oldSend","_len","arguments","sendArgs","_key","apply","concat","oldSetRequestHeader","_len2","setRequestHeaderArgs","_key2","handleSyncRequest","_len3","_key3","requestEventData","_len4","_key4","e","errorEventData","responseEventData","oldOpen","async","_len5","openArgs","_key5","isInitialized","prop","Tracing","listeners","emitted","listener","splice","toTwoDigits","toThreeDigits","getUTCOffset","date","getTimezoneOffset","sign","abs","hours","floor","minutes","d","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","trim","arg","split","row","index","indexOf","str","left","right","list","isFunction","forEachArray","forEachString","forEachObject","array","string","charAt","object","k","fn","alert","confirm","prompt","getEncodingForBlob","UTF8_ENCODING_MIME_TYPES","mimeType","_Constants","MAX_HTTP_BODY_SIZE","contentTypeHeader","includeParts","bodyMessage","convertRawHeaders","rawHeaders","h","lines","l","idx","substring","matches","MULTIPART_FORMDATA_REG_EX","exec","firstBoundaryRegExString","firstBoundaryRegEx","partRegExString","partRegEx","firstBoundary","partSummaries","lastIndex","part","headerSectionLength","bodyStartIndex","convertedHeaders","bodySectionLength","bodyEndIndex","bodyLength","requestId","initiatorType","expectedStart","tryGet","computeDelta","p2","entries","getEntriesByType","candidates","curr","__glimpse_requestId","sort","a","b","deltaA","deltaB","delay","maxDelay","_interopRequireWildcard","newObj","getError","Error","stack","e2","stackFrames","ErrorStackParser","fileName","endsWith","newFrames","functionName","lineNumber","columnNumber","_errorStackParser","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","StackFrame","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","stacktrace","parseOpera","match","parseV8OrIE","parseFFOrSafari","extractLocation","urlLike","regExp","filtered","filter","line","map","tokens","locationParts","pop","parseOpera9","parseOpera11","parseOpera10","lineRE","argsRaw","functionCall","shift","args","_isNumber","n","parseFloat","isFinite","_capitalize","toUpperCase","_getter","booleanProps","numericProps","stringProps","arrayProps","getArgs","setArgs","getEvalOrigin","evalOrigin","setEvalOrigin","getFunctionName","getFileName","getLineNumber","getColumnNumber","Boolean","j","String","_FetchProxy","initiatorRexExp","parsedHeaders","get","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","request","createHeaders","then","getContentTypeHeader","reason","responseEndOffset","EVENT_FETCH_REQUEST_SENT","EVENT_FETCH_RESPONSE_RECEIVED","EVENT_FETCH_ERROR","FetchProxy","self","fetch","oldFetch","input","Request","clone","requestSentEventData","fetchPromise","responseReceivedEventData","_ResourceTimingProxy","EVENT_RESOURCE_TIMING_COLLECTED","createAndPublishMessage","ResourceTimingProxy","_PerformanceUtilities","_PerformanceUtilities2","UPDATE_INTERVAL","processEntry","entry","nextHopProtocol","redirectStart","redirectEnd","fetchStart","domainLookupStart","domainLookupEnd","connectStart","connectEnd","secureConnectionStart","requestStart","transferSize","encodedBodySize","decodedBodySize","record","resources","entriesToPublish","ingressUrl","resource","reportedEntries","getPerformance","webkitPerformance","msPerformance","mozPerformance","_NavigationTimingProxy","EVENT_NAVIGATION_TIMING_COLLECTED","assign","loadDuration","loadEventEnd","domReadyDuration","domComplete","domInteractive","readyStartDuration","navigationStart","redirectDuration","appcacheDuration","unloadEventDuration","unloadEventEnd","unloadEventStart","lookupDomainDuration","connectDuration","requestDuration","initDomTreeDuration","loadEventDuration","loadEventStart","networkRequestDuration","networkResponseDuration","serverDuration","browserDuration","totalDuration","networkDuration","NavigationTimingProxy","processTimings","domContentLoadedEventEnd","domContentLoadedEventStart","domLoading","firstPaint","firstPaintDuration","chrome","loadTimes","firstPaintTime","startLoadTime","msFirstPaint","LogMessageTypes","_ConsoleProxy","countMap","group","profile","time","mapNull","methods","assert","level","processor","count","tokenTypeByPass","debug","nullByPass","dir","json","dirxml","xml","groupStart","groupCollapsed","groupEnd","info","log","profileStart","profileEnd","table","applyType","mapStart","timespan_begin","timeEnd","mapEnd","timespan_end","trace","warn","NOTIFY_CONSOLE_EVENT_OCCURED","library","suppressMessage","deriveTokenType","label","currentCount","assertion","newArgs","processAsDir","getElementsByTagName","nodeCount","outerHTML","getAndApplyLabel","isCollapsed","stackStart","group_begin","stackEnd","group_end","mixin","coreStart","coreEnd","tokenSupport","ConsoleProxy","__glimpse_enabled","methodKey","__glimpse_original","oldFunction","newFunction","__glimpse_proxy","_PerformanceProxy","markIdCache","EVENT_PERFORMANCE_MARK","mark","EVENT_PERFORMANCE_MEASURE","measure","isBuiltIn","startMarkMessageId","startMarkId","endMarkMessageId","endMarkId","correlationMessageIds","category","PerformanceProxy","measureIdCount","tempMeasureName","oldMeasure","tempMeasureEntry","getPerformanceEntryByName","initializeMark","clearMeasures","getEntriesByName","oldMark","performanceEntry","startMark","endMark","_self$oldMeasure","getMarkId","instrumentMark","instrumentMeasure","initializeProxies","proxyName","proxies","proxy","isSupported"],"mappings":"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","file":"agent.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tif (window.Symbol) {\n\t    __webpack_require__(1);\n\t}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _MessagePublisher = __webpack_require__(2);\n\t\n\tvar _XHRInspector = __webpack_require__(7);\n\t\n\tvar _FetchInspector = __webpack_require__(21);\n\t\n\tvar _ResourceTimingInspector = __webpack_require__(23);\n\t\n\tvar _NavigationTimingInspector = __webpack_require__(26);\n\t\n\tvar _ConsoleInspector = __webpack_require__(28);\n\t\n\tvar _PerformanceInspector = __webpack_require__(30);\n\t\n\tvar _initializeProxies = __webpack_require__(32);\n\t\n\tvar _initializeProxies2 = _interopRequireDefault(_initializeProxies);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar messagePublisher = new _MessagePublisher.MessagePublisher();\n\t// We initialize the inspectors before the proxies so that they are wired up and\n\t// ready to receive events from proxies in case a proxy wants to emit an event\n\t// in its `init` method (the Resource Timing proxy does this).\n\tnew _XHRInspector.XHRInspector().init(messagePublisher);\n\tnew _FetchInspector.FetchInspector().init(messagePublisher);\n\tnew _ResourceTimingInspector.ResourceTimingInspector().init(messagePublisher);\n\tnew _NavigationTimingInspector.NavigationTimingInspector().init(messagePublisher);\n\tnew _ConsoleInspector.ConsoleInspector().init(messagePublisher);\n\tnew _PerformanceInspector.PerformanceInspector().init(messagePublisher);\n\t(0, _initializeProxies2['default'])();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.MessagePublisher = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.chunkMessages = chunkMessages;\n\texports.serializeRanges = serializeRanges;\n\t\n\tvar _nanoajax = __webpack_require__(3);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * break a list of messages into group so that the groups are under maxSize.\n\t * If any individual message is over maxSize, it will be grouped on its own.\n\t * returns an of IRange instances, where start is inclusive & end is exclusive.\n\t *\n\t * Exported for test purposes.\n\t */\n\tfunction chunkMessages(messageBodies, maxSize) {\n\t    var ranges = [];\n\t    var sum = 0;\n\t    var lastStart = 0;\n\t    for (var i = 0; i < messageBodies.length; i++) {\n\t        sum += messageBodies[i].length;\n\t        if (messageBodies[i].length > maxSize) {\n\t            if (lastStart !== i) {\n\t                // when a single message is over the limit, we want to send previous messages in their own batch\n\t                ranges.push({ start: lastStart, end: i });\n\t            }\n\t            ranges.push({ start: i, end: i + 1 });\n\t            lastStart = i + 1;\n\t            sum = 0;\n\t        } else if (sum > maxSize) {\n\t            ranges.push({ start: lastStart, end: i });\n\t            lastStart = i;\n\t            sum = messageBodies[i].length;\n\t        }\n\t    }\n\t    if (lastStart < messageBodies.length) {\n\t        ranges.push({ start: lastStart, end: messageBodies.length });\n\t    }\n\t    return ranges;\n\t}\n\t/**\n\t * given an array of serialized message bodies & array of ranges,\n\t * break them into JSON-serialized sub-arrays as defined by the ranges.\n\t *\n\t * Exported for test purposes.\n\t */\n\tfunction serializeRanges(messageBodies, ranges) {\n\t    var payloads = [];\n\t    for (var i = 0; i < ranges.length; i++) {\n\t        if (ranges[i].end > ranges[i].start) {\n\t            var subBodies = messageBodies.slice(ranges[i].start, ranges[i].end);\n\t            var payload = '[' + subBodies.join(',') + ']';\n\t            payloads.push(payload);\n\t        }\n\t    }\n\t    return payloads;\n\t}\n\t\n\tvar MessagePublisher = exports.MessagePublisher = function () {\n\t    function MessagePublisher() {\n\t        _classCallCheck(this, MessagePublisher);\n\t\n\t        this.ordinal = 1;\n\t        this.messageQueue = [];\n\t        this.messageTimeout = undefined;\n\t    }\n\t\n\t    _createClass(MessagePublisher, [{\n\t        key: 'createMessage',\n\t        value: function createMessage(type, payload) {\n\t            var types = Array.isArray(type) ? type : [type];\n\t            var msg = {\n\t                id: (0, _GeneralUtilities.getGuid)(),\n\t                types: types,\n\t                payload: payload,\n\t                context: {\n\t                    id: (0, _RequestUtilities.getRequestId)(),\n\t                    type: 'Request'\n\t                },\n\t                ordinal: this.ordinal++,\n\t                agent: {\n\t                    source: 'browser'\n\t                },\n\t                offset: 0\n\t            };\n\t            (0, _MessageMixins.addOffset)(performance.now(), msg);\n\t            return msg;\n\t        }\n\t    }, {\n\t        key: 'publishMessage',\n\t        value: function publishMessage(message) {\n\t            var _this = this;\n\t\n\t            // finish getting message ready for sending\n\t            message.payload = JSON.stringify(message); // tslint:disable-line:no-string-literal\n\t            // add messages to queu\n\t            this.messageQueue.push(message);\n\t            // only setup the timeout if we need to\n\t            if (!this.messageTimeout) {\n\t                this.messageTimeout = setTimeout(function () {\n\t                    _this.messageTimeout = undefined;\n\t                    _this.sendData();\n\t                }, MessagePublisher.timeout);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'createAndPublishMessage',\n\t        value: function createAndPublishMessage(type, payload) {\n\t            this.publishMessage(this.createMessage(type, payload));\n\t        }\n\t    }, {\n\t        key: 'sendPayload',\n\t        value: function sendPayload(body) {\n\t            // send data with all the data that we have batched up\n\t            (0, _nanoajax.ajax)({\n\t                url: (0, _RequestUtilities.getMessageIngressUrl)(),\n\t                method: 'POST',\n\t                body: body\n\t            }, function () {\n\t                // not doing anything atm\n\t            });\n\t        }\n\t    }, {\n\t        key: 'sendData',\n\t        value: function sendData() {\n\t            var _this2 = this;\n\t\n\t            // we'll chunk the pooled messages into individual requests to try stay under\n\t            // some size limit for http payloads.\n\t            var maxBodySize = (0, _RequestUtilities.getConfigSettingNumber)('server.max.json.body.size', 100000);\n\t            var bodies = [];\n\t            this.messageQueue.forEach(function (m) {\n\t                bodies.push(JSON.stringify(m));\n\t            });\n\t            var ranges = chunkMessages(bodies, maxBodySize);\n\t            var payloads = serializeRanges(bodies, ranges);\n\t            payloads.forEach(function (payload) {\n\t                _this2.sendPayload(payload);\n\t            });\n\t            this.messageQueue = [];\n\t        }\n\t    }]);\n\t\n\t    return MessagePublisher;\n\t}();\n\t\n\tMessagePublisher.timeout = 250;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// Best place to find information on XHR features is:\n\t// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\t\n\tvar reqfields = [\n\t  'responseType', 'withCredentials', 'timeout', 'onprogress'\n\t]\n\t\n\t// Simple and small ajax function\n\t// Takes a parameters object and a callback function\n\t// Parameters:\n\t//  - url: string, required\n\t//  - headers: object of `{header_name: header_value, ...}`\n\t//  - body:\n\t//      + string (sets content type to 'application/x-www-form-urlencoded' if not set in headers)\n\t//      + FormData (doesn't set content type so that browser will set as appropriate)\n\t//  - method: 'GET', 'POST', etc. Defaults to 'GET' or 'POST' based on body\n\t//  - cors: If your using cross-origin, you will need this true for IE8-9\n\t//\n\t// The following parameters are passed onto the xhr object.\n\t// IMPORTANT NOTE: The caller is responsible for compatibility checking.\n\t//  - responseType: string, various compatability, see xhr docs for enum options\n\t//  - withCredentials: boolean, IE10+, CORS only\n\t//  - timeout: long, ms timeout, IE8+\n\t//  - onprogress: callback, IE10+\n\t//\n\t// Callback function prototype:\n\t//  - statusCode from request\n\t//  - response\n\t//    + if responseType set and supported by browser, this is an object of some type (see docs)\n\t//    + otherwise if request completed, this is the string text of the response\n\t//    + if request is aborted, this is \"Abort\"\n\t//    + if request times out, this is \"Timeout\"\n\t//    + if request errors before completing (probably a CORS issue), this is \"Error\"\n\t//  - request object\n\t//\n\t// Returns the request object. So you can call .abort() or other methods\n\t//\n\t// DEPRECATIONS:\n\t//  - Passing a string instead of the params object has been removed!\n\t//\n\texports.ajax = function (params, callback) {\n\t  // Any variable used more than once is var'd here because\n\t  // minification will munge the variables whereas it can't munge\n\t  // the object access.\n\t  var headers = params.headers || {}\n\t    , body = params.body\n\t    , method = params.method || (body ? 'POST' : 'GET')\n\t    , called = false\n\t\n\t  var req = getRequest(params.cors)\n\t\n\t  function cb(statusCode, responseText) {\n\t    return function () {\n\t      if (!called) {\n\t        callback(req.status === undefined ? statusCode : req.status,\n\t                 req.status === 0 ? \"Error\" : (req.response || req.responseText || responseText),\n\t                 req)\n\t        called = true\n\t      }\n\t    }\n\t  }\n\t\n\t  req.open(method, params.url, true)\n\t\n\t  var success = req.onload = cb(200)\n\t  req.onreadystatechange = function () {\n\t    if (req.readyState === 4) success()\n\t  }\n\t  req.onerror = cb(null, 'Error')\n\t  req.ontimeout = cb(null, 'Timeout')\n\t  req.onabort = cb(null, 'Abort')\n\t\n\t  if (body) {\n\t    setDefault(headers, 'X-Requested-With', 'XMLHttpRequest')\n\t\n\t    if (!global.FormData || !(body instanceof global.FormData)) {\n\t      setDefault(headers, 'Content-Type', 'application/x-www-form-urlencoded')\n\t    }\n\t  }\n\t\n\t  for (var i = 0, len = reqfields.length, field; i < len; i++) {\n\t    field = reqfields[i]\n\t    if (params[field] !== undefined)\n\t      req[field] = params[field]\n\t  }\n\t\n\t  for (var field in headers)\n\t    req.setRequestHeader(field, headers[field])\n\t\n\t  req.send(body)\n\t\n\t  return req\n\t}\n\t\n\tfunction getRequest(cors) {\n\t  // XDomainRequest is only way to do CORS in IE 8 and 9\n\t  // But XDomainRequest isn't standards-compatible\n\t  // Notably, it doesn't allow cookies to be sent or set by servers\n\t  // IE 10+ is standards-compatible in its XMLHttpRequest\n\t  // but IE 10 can still have an XDomainRequest object, so we don't want to use it\n\t  if (cors && global.XDomainRequest && !/MSIE 1/.test(navigator.userAgent))\n\t    return new XDomainRequest\n\t  if (global.XMLHttpRequest)\n\t    return new XMLHttpRequest\n\t}\n\t\n\tfunction setDefault(obj, key, value) {\n\t  obj[key] = obj[key] || value\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getGuid = getGuid;\n\texports.convertBlobToText = convertBlobToText;\n\tfunction getGuid() {\n\t    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        /* tslint:disable:no-bitwise */\n\t        var r = Math.random() * 16 | 0,\n\t            v = c === 'x' ? r : r & 0x3 | 0x8;\n\t        /* tslint:enable:no-bitwise */\n\t        return v.toString(16);\n\t    });\n\t}\n\tfunction convertBlobToText(blob, encoding, cb) {\n\t    var fileReader = new FileReader();\n\t    fileReader.onloadend = function () {\n\t        cb(fileReader.result);\n\t    };\n\t    fileReader.readAsText(blob, encoding);\n\t}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getRequestId = getRequestId;\n\texports.getConfigSettingNumber = getConfigSettingNumber;\n\texports.getConfigSettings = getConfigSettings;\n\texports.addEvent = addEvent;\n\texports.getCookie = getCookie;\n\texports.getHeaderKeys = getHeaderKeys;\n\texports.normalizeHeaders = normalizeHeaders;\n\texports.getMessageIngressUrl = getMessageIngressUrl;\n\texports.parseUrl = parseUrl;\n\texports.stringifyUrl = stringifyUrl;\n\texports.resolveUrl = resolveUrl;\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tfunction getRequestId() {\n\t    // NOTE: agent should look to see if it can get the id\n\t    //       from a script tag first, then if it can't find\n\t    //       it there look to for a cookie (in the case where\n\t    //       we can't inject a script tag) and finally it will\n\t    //       create one which will be used moving forward\n\t    //       (CDN scenario).\n\t    var id = document.getElementById('__glimpse_browser_agent').getAttribute('data-request-id');\n\t    if (!id) {\n\t        id = getCookie('.Glimpse.RequestId');\n\t    }\n\t    if (!id) {\n\t        id = (0, _GeneralUtilities.getGuid)();\n\t    }\n\t    return id;\n\t}\n\tfunction getConfigSettingNumber(key, defaultValue, settings) {\n\t    var value = defaultValue;\n\t    if (!settings) {\n\t        settings = getConfigSettings();\n\t    }\n\t    if (settings && settings.hasOwnProperty(key)) {\n\t        var v = settings[key];\n\t        if (typeof v === 'string') {\n\t            var num = parseInt(v, 10);\n\t            if (!Number.isNaN(num)) {\n\t                value = num;\n\t            }\n\t        } else if (typeof v === 'number') {\n\t            value = v;\n\t        }\n\t    }\n\t    return value;\n\t}\n\tfunction getConfigSettings() {\n\t    var settings = {};\n\t    var el = document.getElementById('__glimpse_browser_agent');\n\t    if (el) {\n\t        var val = el.getAttribute('config-settings');\n\t        if (settings) {\n\t            try {\n\t                settings = JSON.parse(val);\n\t            } catch (err) {\n\t                // tslint:disable-next-line:no-console\n\t                console.error('Error parsing config settings: ' + err);\n\t            }\n\t        }\n\t    }\n\t    return settings;\n\t}\n\tfunction addEvent(element, eventName, cb) {\n\t    if (element.addEventListener) {\n\t        element.addEventListener(eventName, cb, false);\n\t    } else if (element.attachEvent) {\n\t        element.attachEvent('on' + eventName, cb);\n\t    }\n\t}\n\tfunction getCookie(cookie) {\n\t    // Modified from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie\n\t    var regexp = new RegExp('(?:(?:^|.*;\\\\s*)' + cookie + '\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$');\n\t    return document.cookie.replace(regexp, '$1');\n\t}\n\tfunction getHeaderKeys(headers) {\n\t    var headerKeys = [];\n\t    // tslint:disable-next-line:no-any\n\t    if (headers.keys) {\n\t        // tslint:disable-next-line:no-any\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t            for (var _iterator = headers.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                var header = _step.value;\n\t\n\t                headerKeys.push(header);\n\t            }\n\t        } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t        } finally {\n\t            try {\n\t                if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                    _iterator['return']();\n\t                }\n\t            } finally {\n\t                if (_didIteratorError) {\n\t                    throw _iteratorError;\n\t                }\n\t            }\n\t        }\n\t    } else if (headers.forEach) {\n\t        headers.forEach(function (value, name) {\n\t            return headerKeys.push(name);\n\t        });\n\t    }\n\t    return headerKeys;\n\t}\n\t// Headers are not technically case sensitive, and the browser often normalizes\n\t// header so that they are all lower case and all strings. This method does the\n\t// same so that headers are always normalized from the browser agent in all cases.\n\tfunction normalizeHeaders(headers) {\n\t    var normalizedHeaders = {};\n\t    for (var header in headers) {\n\t        if (!headers.hasOwnProperty(header)) {\n\t            continue;\n\t        }\n\t        var headerVal = headers[header];\n\t        // tslint:disable-next-line:no-null-keyword\n\t        if (headerVal !== undefined && headerVal !== null && typeof headerVal !== 'string') {\n\t            headerVal = headerVal.toString();\n\t        }\n\t        normalizedHeaders[header.toLowerCase()] = headerVal;\n\t    }\n\t    return normalizedHeaders;\n\t}\n\tfunction getMessageIngressUrl() {\n\t    return document.getElementById('__glimpse_browser_agent').getAttribute('data-message-ingress-template');\n\t}\n\tfunction parseUrl(url) {\n\t    var parser = document.createElement('a');\n\t    parser.href = url;\n\t    var parsedPort = parseInt(parser.port, 10);\n\t    return {\n\t        protocol: parser.protocol,\n\t        hostname: parser.hostname,\n\t        port: isNaN(parsedPort) ? undefined : parsedPort,\n\t        pathname: parser.pathname,\n\t        search: parser.search,\n\t        hash: parser.hash\n\t    };\n\t}\n\tfunction stringifyUrl(url) {\n\t    var portSuffix = url.port !== undefined ? ':' + url.port : '';\n\t    var stringifiedUrl = url.protocol + '//' + url.hostname + portSuffix + url.pathname;\n\t    if (url.search) {\n\t        stringifiedUrl += url.search;\n\t    }\n\t    if (url.hash) {\n\t        stringifiedUrl += url.hash;\n\t    }\n\t    return stringifiedUrl;\n\t}\n\tvar urlCache = {};\n\tfunction resolveUrl(url) {\n\t    if (urlCache[url]) {\n\t        return urlCache[url];\n\t    }\n\t    return urlCache[url] = stringifyUrl(parseUrl(url));\n\t}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.addOffset = addOffset;\n\texports.addCorrelationBegin = addCorrelationBegin;\n\texports.addCorrelationEnd = addCorrelationEnd;\n\texports.addCorrelation = addCorrelation;\n\tfunction addOffset(offset, envelope) {\n\t    envelope.offset = offset;\n\t}\n\tfunction addCorrelationBegin(correlationId, envelope) {\n\t    envelope.types.push('correlation-begin');\n\t    addCorrelation(correlationId, envelope);\n\t}\n\tfunction addCorrelationEnd(correlationId, duration, envelope) {\n\t    envelope.types.push('correlation-end');\n\t    envelope.payload.duration = duration;\n\t    addCorrelation(correlationId, envelope);\n\t}\n\tfunction addCorrelation(correlationId, envelope) {\n\t    envelope.types.push('correlation');\n\t    envelope.payload.correlationId = correlationId;\n\t}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.XHRInspector = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GlimpseLogger = __webpack_require__(8);\n\t\n\tvar _GlimpseLogger2 = _interopRequireDefault(_GlimpseLogger);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _XHRProxy = __webpack_require__(9);\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _DateTimeUtilities = __webpack_require__(11);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _parseHeaders = __webpack_require__(12);\n\t\n\tvar _parseHeaders2 = _interopRequireDefault(_parseHeaders);\n\t\n\tvar _HttpRequestUtils = __webpack_require__(16);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar XHRInspector = exports.XHRInspector = function () {\n\t    function XHRInspector() {\n\t        _classCallCheck(this, XHRInspector);\n\t\n\t        this.initiatorRegExp = /xmlhttprequest/i;\n\t        this.requests = {};\n\t    }\n\t\n\t    _createClass(XHRInspector, [{\n\t        key: 'createBodyProperty',\n\t        value: function createBodyProperty(headers, body, cb) {\n\t            //\n\t            // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n\t            // irrespective of whether createBodyForBlob is called.  For a more in-depth discussion,\n\t            // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n\t            //\n\t            if (!body) {\n\t                var bodyProperty = (0, _HttpRequestUtils.createEmptyBody)(false);\n\t                setTimeout(function () {\n\t                    return cb(bodyProperty);\n\t                }, 0);\n\t            } else {\n\t                //\n\t                // according to MDN docs, body here can be one of the following types:\n\t                // ArrayBufferView | Blob | Document | string | FormData.  We need to\n\t                // account for all of these.\n\t                //\n\t                if (typeof body === 'string') {\n\t                    var contentType = headers['content-type'];\n\t                    var boundary = (0, _HttpRequestUtils.getMultiPartFormBoundary)(contentType);\n\t                    var _bodyProperty = {\n\t                        size: body.length,\n\t                        encoding: 'utf8',\n\t                        isTruncated: body.length > (0, _HttpRequestUtils.getMaxHTTPBodySize)(),\n\t                        parts: (0, _HttpRequestUtils.getMultiPartFormParts)(boundary, body),\n\t                        content: body.slice(0, (0, _HttpRequestUtils.getMaxHTTPBodySize)())\n\t                    };\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty);\n\t                    }, 0);\n\t                } else if (body instanceof Blob) {\n\t                    var _contentType = headers['content-type'];\n\t                    var blob = body;\n\t                    (0, _HttpRequestUtils.createBodyForBlob)(_contentType, blob, true, function (bodyProperty) {\n\t                        cb(bodyProperty);\n\t                    });\n\t                } else if (body instanceof ArrayBuffer || body.buffer && body.buffer instanceof ArrayBuffer) {\n\t                    var buffer = void 0;\n\t                    if (body instanceof ArrayBuffer) {\n\t                        buffer = body;\n\t                    } else {\n\t                        buffer = body.buffer;\n\t                    }\n\t                    // TODO:  support body capture when body is ArrayBuffer\n\t                    var _bodyProperty2 = {\n\t                        size: buffer.byteLength,\n\t                        encoding: 'none',\n\t                        isTruncated: true,\n\t                        parts: [],\n\t                        content: ''\n\t                    };\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty2);\n\t                    }, 0);\n\t                } else if (body instanceof Document) {\n\t                    // TODO:  support body capture when body is Document\n\t                    var doc = body;\n\t                    var _bodyProperty3 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty3);\n\t                    }, 0);\n\t                } else if (body instanceof FormData) {\n\t                    // TODO:  support body capture when body is FormData\n\t                    var fd = body;\n\t                    var _bodyProperty4 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty4);\n\t                    }, 0);\n\t                } else if ((typeof body === 'undefined' ? 'undefined' : _typeof(body)) === 'object') {\n\t                    // TODO:  support body capture when body is object\n\t                    var _bodyProperty5 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty5);\n\t                    }, 0);\n\t                } else {\n\t                    var _bodyProperty6 = (0, _HttpRequestUtils.createEmptyBody)(true);\n\t                    setTimeout(function () {\n\t                        return cb(_bodyProperty6);\n\t                    }, 0);\n\t                }\n\t            }\n\t        }\n\t    }, {\n\t        key: 'before',\n\t        value: function before(event) {\n\t            var _this = this;\n\t\n\t            var eventData = event.data;\n\t            var url = (0, _RequestUtilities.parseUrl)(eventData.url);\n\t            var headers = (0, _RequestUtilities.normalizeHeaders)(eventData.headers);\n\t            (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                _this.createBodyProperty(headers, eventData.body, function (body) {\n\t                    var startTime = (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp));\n\t                    var msg = _this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n\t                        correlationId: eventData.id,\n\t                        protocol: {\n\t                            identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n\t                        },\n\t                        url: eventData.url,\n\t                        method: eventData.method,\n\t                        startTime: startTime,\n\t                        timing: {\n\t                            startTime: 0\n\t                        },\n\t                        headers: headers,\n\t                        isAjax: true,\n\t                        body: body,\n\t                        frames: frames.slice(0, 1)\n\t                    });\n\t                    (0, _MessageMixins.addOffset)(event.offset, msg);\n\t                    _this.messagePublisher.publishMessage(msg);\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'after',\n\t        value: function after(event, requestEntry) {\n\t            var _this2 = this;\n\t\n\t            var eventData = event.data;\n\t            (0, _HttpRequestUtils.tryFindResourceTimingObject)(event.data.id, this.initiatorRegExp, eventData.url, requestEntry.startTimeOffset, function (timings) {\n\t                var offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n\t                // start here is relative to this http client request, so it is always 0\n\t                var startTime = 0;\n\t                // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n\t                var responseStart = timings && timings.responseStart >= timings.startTime ? timings.responseStart - timings.startTime : undefined;\n\t                var responseEnd = timings ? timings.responseEnd - timings.startTime : event.offset - requestEntry.startTimeOffset;\n\t                var headers = (0, _parseHeaders2['default'])(eventData.xhr.getAllResponseHeaders());\n\t                // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n\t                // Add support for base64 encoding non-text content by setting the encoding here\n\t                _this2.createBodyProperty(headers, eventData.body, function (body) {\n\t                    var msg = _this2.messagePublisher.createMessage('data-http-response', {\n\t                        correlationId: eventData.id,\n\t                        url: eventData.url,\n\t                        headers: headers,\n\t                        statusCode: eventData.statusCode,\n\t                        statusMessage: eventData.statusMessage,\n\t                        endTime: (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp)),\n\t                        duration: responseEnd,\n\t                        timing: {\n\t                            startTime: 0,\n\t                            responseEnd: responseEnd\n\t                        },\n\t                        body: body\n\t                    });\n\t                    if (responseStart !== undefined) {\n\t                        msg.payload.timing.responseStart = responseStart;\n\t                    }\n\t                    (0, _MessageMixins.addOffset)(offset, msg);\n\t                    _this2.messagePublisher.publishMessage(msg);\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'numOutstandingRequests',\n\t        value: function numOutstandingRequests() {\n\t            return Object.keys(this.requests).length;\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this3 = this;\n\t\n\t            this.messagePublisher = messagePublisher;\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_REQUEST_SENT, function (event) {\n\t                _this3.requests[event.data.id] = {\n\t                    startTimeStamp: event.timeStamp,\n\t                    startTimeOffset: event.offset\n\t                };\n\t                _this3.before(event);\n\t            });\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_RESPONSE_RECEIVED, function (event) {\n\t                var requestEntry = _this3.requests[event.data.id];\n\t                if (!requestEntry) {\n\t                    _GlimpseLogger2['default'].error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n\t                    return;\n\t                }\n\t                _this3.after(event, requestEntry);\n\t                delete _this3.requests[event.data.id];\n\t            });\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_ERROR, function (data) {\n\t                delete _this3.requests[data.data.id];\n\t            });\n\t            _Tracing2['default'].on(_XHRProxy.EVENT_XHR_ABORT, function (data) {\n\t                delete _this3.requests[data.data.id];\n\t            });\n\t        }\n\t    }]);\n\n\t    return XHRInspector;\n\t}();\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GlimpseLogger = exports.GlimpseLogger = function () {\n\t    function GlimpseLogger(logToConsole) {\n\t        _classCallCheck(this, GlimpseLogger);\n\t\n\t        this.logToConsole = logToConsole;\n\t    }\n\t\n\t    _createClass(GlimpseLogger, [{\n\t        key: \"error\",\n\t        value: function error(message) {\n\t            if (this.logToConsole) {\n\t                // tslint:disable-next-line:no-console\n\t                console.error(message);\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return GlimpseLogger;\n\t}();\n\t\n\tvar logger = new GlimpseLogger((false));\n\texports[\"default\"] = logger;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.XHRProxy = exports.EVENT_XHR_ABORT = exports.EVENT_XHR_ERROR = exports.EVENT_XHR_RESPONSE_RECEIVED = exports.EVENT_XHR_REQUEST_SENT = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GlimpseLogger = __webpack_require__(8);\n\t\n\tvar _GlimpseLogger2 = _interopRequireDefault(_GlimpseLogger);\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_XHR_REQUEST_SENT = exports.EVENT_XHR_REQUEST_SENT = 'invoke|pre|XMLHttpRequest.request-sent';\n\tvar EVENT_XHR_RESPONSE_RECEIVED = exports.EVENT_XHR_RESPONSE_RECEIVED = 'notify|XMLHttpRequest.response-received';\n\tvar EVENT_XHR_ERROR = exports.EVENT_XHR_ERROR = 'notify|XMLHttpRequest.error';\n\tvar EVENT_XHR_ABORT = exports.EVENT_XHR_ABORT = 'notify|XMLHttpRequest.abort';\n\t/**\n\t * Proxy which wraps XHR usage and its various supporting functions.\n\t *\n\t * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n\t */\n\t\n\tvar XHRProxy = exports.XHRProxy = function () {\n\t    function XHRProxy() {\n\t        _classCallCheck(this, XHRProxy);\n\t    }\n\t\n\t    _createClass(XHRProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n\t            // reference the property this way to get around TypeScript\n\t            //tslint:disable-next-line:no-any\n\t            return !!(window && typeof window.XMLHttpRequest !== 'undefined');\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            if (XHRProxy.isInitialized) {\n\t                _GlimpseLogger2['default'].error('Glimpse Error: Cannot initialize the XHR Proxy more than once.');\n\t                return;\n\t            }\n\t            //tslint:disable-next-line:no-any\n\t            var oldXMLHttpRequest = window.XMLHttpRequest;\n\t            function XMLHttpRequest() {\n\t                var xhr = new oldXMLHttpRequest();\n\t                var id = (0, _GeneralUtilities.getGuid)();\n\t                function handleAsyncRequest(method, url) {\n\t                    var requestHeaders = {};\n\t                    xhr.addEventListener('readystatechange', function () {\n\t                        if (xhr.readyState === oldXMLHttpRequest.DONE) {\n\t                            var eventData = {\n\t                                id: id,\n\t                                xhr: xhr,\n\t                                url: (0, _RequestUtilities.resolveUrl)(url),\n\t                                statusCode: xhr.status,\n\t                                statusMessage: xhr.statusText,\n\t                                bodyType: xhr.responseType,\n\t                                body: xhr.response\n\t                            };\n\t                            _Tracing2['default'].publish(EVENT_XHR_RESPONSE_RECEIVED, eventData);\n\t                        }\n\t                        ;\n\t                    });\n\t                    xhr.addEventListener('error', function () {\n\t                        var eventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            error: xhr.statusText\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_ERROR, eventData);\n\t                    });\n\t                    xhr.addEventListener('abort', function () {\n\t                        var eventData = {\n\t                            id: id,\n\t                            xhr: xhr\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_ABORT, eventData);\n\t                    });\n\t                    var oldSend = xhr.send;\n\t                    xhr.send = function send(body) {\n\t                        var eventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            method: method,\n\t                            url: (0, _RequestUtilities.resolveUrl)(url),\n\t                            body: body,\n\t                            headers: requestHeaders\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_REQUEST_SENT, eventData);\n\t\n\t                        for (var _len = arguments.length, sendArgs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                            sendArgs[_key - 1] = arguments[_key];\n\t                        }\n\t\n\t                        oldSend.call.apply(oldSend, [this, body].concat(sendArgs));\n\t                    };\n\t                    var oldSetRequestHeader = xhr.setRequestHeader;\n\t                    xhr.setRequestHeader = function setRequestHeader(header, value) {\n\t                        requestHeaders[header] = value;\n\t\n\t                        for (var _len2 = arguments.length, setRequestHeaderArgs = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n\t                            setRequestHeaderArgs[_key2 - 2] = arguments[_key2];\n\t                        }\n\t\n\t                        oldSetRequestHeader.call.apply(oldSetRequestHeader, [this, header, value].concat(setRequestHeaderArgs));\n\t                    };\n\t                }\n\t                function handleSyncRequest(method, url) {\n\t                    var oldSend = xhr.send;\n\t                    var requestHeaders = {};\n\t                    var oldSetRequestHeader = xhr.setRequestHeader;\n\t                    xhr.setRequestHeader = function setRequestHeader(header, value) {\n\t                        requestHeaders[header] = value;\n\t\n\t                        for (var _len3 = arguments.length, setRequestHeaderArgs = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n\t                            setRequestHeaderArgs[_key3 - 2] = arguments[_key3];\n\t                        }\n\t\n\t                        oldSetRequestHeader.call.apply(oldSetRequestHeader, [this, header, value].concat(setRequestHeaderArgs));\n\t                    };\n\t                    xhr.send = function send(body) {\n\t                        var requestEventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            method: method,\n\t                            url: (0, _RequestUtilities.resolveUrl)(url),\n\t                            body: body,\n\t                            headers: requestHeaders\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_REQUEST_SENT, requestEventData);\n\t                        try {\n\t                            for (var _len4 = arguments.length, sendArgs = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t                                sendArgs[_key4 - 1] = arguments[_key4];\n\t                            }\n\t\n\t                            oldSend.call.apply(oldSend, [this, body].concat(sendArgs));\n\t                        } catch (e) {\n\t                            var errorEventData = {\n\t                                id: id,\n\t                                xhr: xhr,\n\t                                error: e.message\n\t                            };\n\t                            _Tracing2['default'].publish(EVENT_XHR_ERROR, errorEventData);\n\t                            throw e;\n\t                        }\n\t                        var responseEventData = {\n\t                            id: id,\n\t                            xhr: xhr,\n\t                            url: (0, _RequestUtilities.resolveUrl)(url),\n\t                            statusCode: xhr.status,\n\t                            statusMessage: xhr.statusText || '',\n\t                            bodyType: xhr.responseType,\n\t                            body: xhr.response\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_XHR_RESPONSE_RECEIVED, responseEventData);\n\t                    };\n\t                }\n\t                var oldOpen = xhr.open;\n\t                xhr.open = function open(method, url) {\n\t                    var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t                    for (var _len5 = arguments.length, openArgs = Array(_len5 > 3 ? _len5 - 3 : 0), _key5 = 3; _key5 < _len5; _key5++) {\n\t                        openArgs[_key5 - 3] = arguments[_key5];\n\t                    }\n\t\n\t                    var result = oldOpen.call.apply(oldOpen, [this, method, url, async].concat(openArgs));\n\t                    // If the url equals the message ingress url, that means it's\n\t                    // a Glimpse message and we don't want to profile it\n\t                    if (url !== (0, _RequestUtilities.getMessageIngressUrl)()) {\n\t                        if (async) {\n\t                            handleAsyncRequest(method, url);\n\t                        } else {\n\t                            handleSyncRequest(method, url);\n\t                        }\n\t                    }\n\t                    return result;\n\t                };\n\t                return xhr;\n\t            }\n\t            // Copy the states (and anything else) from the original object to our proxy\n\t            for (var prop in oldXMLHttpRequest) {\n\t                if (oldXMLHttpRequest.hasOwnProperty(prop)) {\n\t                    XMLHttpRequest[prop] = oldXMLHttpRequest[prop];\n\t                }\n\t            }\n\t            // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n\t            // reference the property this way to get around TypeScript, but we also have to\n\t            // disable tslint in the process\n\t            /* tslint:disable */\n\t            window['XMLHttpRequest'] = XMLHttpRequest;\n\t            /* tslint:enable */\n\t            XHRProxy.isInitialized = true;\n\t        }\n\t    }]);\n\t\n\t    return XHRProxy;\n\t}();\n\t\n\tXHRProxy.isInitialized = false;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * The Tracing module provides mechanisms for registering to receive tracing\n\t * events from proxies.\n\t *\n\t * This module is pretty similar to a standard EventEmitter, but has a few\n\t * key differences. This module provides the ability to filter out which\n\t * events you would like to receive, based on criteria of your choosing.\n\t *\n\t * Tracing can hurt performance in some cases, and filtering is a way for\n\t * the profiling application to improve performance whenever the data is not\n\t * explicitly needed.\n\t *\n\t * @module tracing/Tracing\n\t */\n\tvar Tracing = function () {\n\t    function Tracing() {\n\t        _classCallCheck(this, Tracing);\n\t\n\t        this.listeners = {};\n\t    }\n\t    /**\n\t     * Publishes an event, similar to the `EventEmitter.emit` method except that it\n\t     * does not accept more than one data argument.\n\t     *\n\t     * @param {string} event - The name of the event to fire, and should include a\n\t     *      descriptive namespace, e.g. `http.request:request-created`\n\t     * @param {object} data - The data associated with the event\n\t     * @returns {boolean} - Whether or not the event was published to any listeners\n\t     */\n\t\n\t\n\t    _createClass(Tracing, [{\n\t        key: \"publish\",\n\t        value: function publish(event, data) {\n\t            var listeners = this.listeners[event];\n\t            if (!listeners || listeners.length === 0) {\n\t                return false;\n\t            }\n\t            var emitted = false;\n\t            var message = {\n\t                offset: performance.now(),\n\t                timeStamp: Date.now(),\n\t                data: data\n\t            };\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var listener = _step.value;\n\t\n\t                    emitted = true;\n\t                    listener.listener(message);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator[\"return\"]) {\n\t                        _iterator[\"return\"]();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return emitted;\n\t        }\n\t        /**\n\t         * Register to always receive an event without any filtering. This module is\n\t         * returned from this method, making it possible to chain `removeEventListener`\n\t         * calls.\n\t         *\n\t         * Note: if any other listeners are filtering this event, registering with\n\t         * this method will prevent the proxies from enabling any performance\n\t         * optimizations.\n\t         *\n\t         * Calling this method is equivalent to calling `onFiltered(event, listener, () => true)`\n\t         *\n\t         * @param {string} event - The name of the event to listen to, e.g.\n\t         *      `http.request:request-created`\n\t         * @param {function} listener - The callback to call when the event is emitted\n\t         */\n\t\n\t    }, {\n\t        key: \"on\",\n\t        value: function on(event, listener) {\n\t            if (!this.listeners[event]) {\n\t                this.listeners[event] = [];\n\t            }\n\t            this.listeners[event].push({\n\t                listener: listener\n\t            });\n\t            return this;\n\t        }\n\t        /**\n\t         * Removes exactly one registered event listener. If the same callback is\n\t         * registered more than once, only the first copy is removed. This behavior\n\t         * mimics that of EventEmitter.removeEventListener\n\t         *\n\t         * @param {string} event - The name of the event to remove the listener for,\n\t         *      e.g. `http.request:request-created`\n\t         * @param {function} listener - The listener to remove\n\t         * @returns {object} A refernce to this module, making it possible to chain\n\t         *      removeEventListener calls\n\t         */\n\t\n\t    }, {\n\t        key: \"removeEventListener\",\n\t        value: function removeEventListener(event, listener) {\n\t            var listeners = this.listeners[event];\n\t            if (!listeners) {\n\t                // Matches Node.js removeEventListener return signature\n\t                return this;\n\t            }\n\t            for (var i = 0; i < listeners.length; i++) {\n\t                if (listeners[i].listener === listener) {\n\t                    this.listeners[event].splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t            return this;\n\t        }\n\t        /**\n\t         * Removes all listeners for the given event. If no event is specified, then\n\t         * all event listeners for all events are removed.\n\t         *\n\t         * @param {string} event - (Optional) The event to remove listeners for\n\t         * @returns {object} A refernce to this module, making it possible to chain calls\n\t         */\n\t\n\t    }, {\n\t        key: \"removeAllListeners\",\n\t        value: function removeAllListeners(event) {\n\t            if (event) {\n\t                if (this.listeners[event]) {\n\t                    this.listeners[event] = [];\n\t                }\n\t            } else {\n\t                this.listeners = {};\n\t            }\n\t            return this;\n\t        }\n\t        /**\n\t         * Returns the number of listeners for the given event. This behavior\n\t         * mimics that of EventEmitter.listenerCount\n\t         *\n\t         * @param {string} event - The event to count listeners for\n\t         * @returns {number} The number of listeners for the given event\n\t         */\n\t\n\t    }, {\n\t        key: \"listenerCount\",\n\t        value: function listenerCount(event) {\n\t            if (!this.listeners[event]) {\n\t                return 0;\n\t            }\n\t            return this.listeners[event].length;\n\t        }\n\t    }]);\n\t\n\t    return Tracing;\n\t}();\n\t\n\texports[\"default\"] = new Tracing();\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getDateTime = getDateTime;\n\tfunction toTwoDigits(value) {\n\t    return value < 10 ? '0' + value : value;\n\t}\n\tfunction toThreeDigits(value) {\n\t    if (value < 10) {\n\t        return '00' + value;\n\t    }\n\t    if (value < 100) {\n\t        return '0' + value;\n\t    }\n\t    return value;\n\t}\n\tfunction getUTCOffset(date) {\n\t    var offset = date.getTimezoneOffset();\n\t    var sign = offset >= 0 ? '+' : '-';\n\t    offset = Math.abs(offset);\n\t    var hours = toTwoDigits(Math.floor(offset / 60));\n\t    var minutes = toTwoDigits(offset % 60);\n\t    return sign + hours + minutes;\n\t}\n\t// Convert time according to the format string: 'YYYY-MM-DDTHH:mm:ss.SSS ZZ'\n\t// Output should look like: \"2016-06-08T09:07:11.021 -0700\"\n\tfunction getDateTime() {\n\t    var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n\t\n\t    return d.getFullYear() + '-' + toTwoDigits(d.getMonth() + 1) + '-' + toTwoDigits(d.getDate()) + 'T' + toTwoDigits(d.getHours()) + ':' + toTwoDigits(d.getMinutes()) + ':' + toTwoDigits(d.getSeconds()) + '.' + toThreeDigits(d.getMilliseconds()) + getUTCOffset(d);\n\t}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar trim = __webpack_require__(13)\n\t  , forEach = __webpack_require__(14)\n\t  , isArray = function(arg) {\n\t      return Object.prototype.toString.call(arg) === '[object Array]';\n\t    }\n\t\n\tmodule.exports = function (headers) {\n\t  if (!headers)\n\t    return {}\n\t\n\t  var result = {}\n\t\n\t  forEach(\n\t      trim(headers).split('\\n')\n\t    , function (row) {\n\t        var index = row.indexOf(':')\n\t          , key = trim(row.slice(0, index)).toLowerCase()\n\t          , value = trim(row.slice(index + 1))\n\t\n\t        if (typeof(result[key]) === 'undefined') {\n\t          result[key] = value\n\t        } else if (isArray(result[key])) {\n\t          result[key].push(value)\n\t        } else {\n\t          result[key] = [ result[key], value ]\n\t        }\n\t      }\n\t  )\n\t\n\t  return result\n\t}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t\n\texports = module.exports = trim;\n\t\n\tfunction trim(str){\n\t  return str.replace(/^\\s*|\\s*$/g, '');\n\t}\n\t\n\texports.left = function(str){\n\t  return str.replace(/^\\s*/, '');\n\t};\n\t\n\texports.right = function(str){\n\t  return str.replace(/\\s*$/, '');\n\t};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isFunction = __webpack_require__(15)\n\t\n\tmodule.exports = forEach\n\t\n\tvar toString = Object.prototype.toString\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty\n\t\n\tfunction forEach(list, iterator, context) {\n\t    if (!isFunction(iterator)) {\n\t        throw new TypeError('iterator must be a function')\n\t    }\n\t\n\t    if (arguments.length < 3) {\n\t        context = this\n\t    }\n\t    \n\t    if (toString.call(list) === '[object Array]')\n\t        forEachArray(list, iterator, context)\n\t    else if (typeof list === 'string')\n\t        forEachString(list, iterator, context)\n\t    else\n\t        forEachObject(list, iterator, context)\n\t}\n\t\n\tfunction forEachArray(array, iterator, context) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t        if (hasOwnProperty.call(array, i)) {\n\t            iterator.call(context, array[i], i, array)\n\t        }\n\t    }\n\t}\n\t\n\tfunction forEachString(string, iterator, context) {\n\t    for (var i = 0, len = string.length; i < len; i++) {\n\t        // no such thing as a sparse string.\n\t        iterator.call(context, string.charAt(i), i, string)\n\t    }\n\t}\n\t\n\tfunction forEachObject(object, iterator, context) {\n\t    for (var k in object) {\n\t        if (hasOwnProperty.call(object, k)) {\n\t            iterator.call(context, object[k], k, object)\n\t        }\n\t    }\n\t}\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = isFunction\n\t\n\tvar toString = Object.prototype.toString\n\t\n\tfunction isFunction (fn) {\n\t  var string = toString.call(fn)\n\t  return string === '[object Function]' ||\n\t    (typeof fn === 'function' && string !== '[object RegExp]') ||\n\t    (typeof window !== 'undefined' &&\n\t     // IE8 and below\n\t     (fn === window.setTimeout ||\n\t      fn === window.alert ||\n\t      fn === window.confirm ||\n\t      fn === window.prompt))\n\t};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.createEmptyBody = createEmptyBody;\n\texports.getMaxHTTPBodySize = getMaxHTTPBodySize;\n\texports.createBodyForBlob = createBodyForBlob;\n\texports.getMultiPartFormBoundary = getMultiPartFormBoundary;\n\texports.getMultiPartFormParts = getMultiPartFormParts;\n\texports.tryFindResourceTimingObject = tryFindResourceTimingObject;\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _Constants = __webpack_require__(17);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\t/**\n\t * set of regular expressions that match a mime type when the encoding of a payload is UTF8\n\t */\n\tvar UTF8_ENCODING_MIME_TYPES = [/^text\\//, /^application\\/.*?xml/, /^application\\/json/, /^application\\/javascript/, /^application\\/x-www-form-urlencoded/, /^multipart\\/form-data/];\n\t/**\n\t * Infer the encoding type given a blob\n\t *\n\t * @param blob The blob to get the encoding for\n\t */\n\tfunction getEncodingForBlob(blob) {\n\t    var encoding = 'none';\n\t    var _iteratorNormalCompletion = true;\n\t    var _didIteratorError = false;\n\t    var _iteratorError = undefined;\n\t\n\t    try {\n\t        for (var _iterator = UTF8_ENCODING_MIME_TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var mimeType = _step.value;\n\t\n\t            if (mimeType.test(blob.type)) {\n\t                encoding = 'utf8';\n\t                break;\n\t            }\n\t        }\n\t    } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t    } finally {\n\t        try {\n\t            if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                _iterator['return']();\n\t            }\n\t        } finally {\n\t            if (_didIteratorError) {\n\t                throw _iteratorError;\n\t            }\n\t        }\n\t    }\n\t\n\t    return encoding;\n\t}\n\tfunction createEmptyBody(isTruncated) {\n\t    return {\n\t        size: 0,\n\t        encoding: 'none',\n\t        content: '',\n\t        isTruncated: isTruncated\n\t    };\n\t}\n\tfunction getMaxHTTPBodySize() {\n\t    return (0, _RequestUtilities.getConfigSettingNumber)('inspector.http.body.capture.maxsize', _Constants.MAX_HTTP_BODY_SIZE);\n\t}\n\tfunction createBodyForBlob(contentTypeHeader, blob, includeParts, cb) {\n\t    // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n\t    // Add support for base64 encoding non-text content by setting the encoding here\n\t    // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n\t    // irrespective of whether convertBlobtoText is called.  For a more in-depth discussion,\n\t    // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n\t    if (blob.size) {\n\t        var encoding = getEncodingForBlob(blob);\n\t        switch (encoding) {\n\t            case 'utf8':\n\t                (0, _GeneralUtilities.convertBlobToText)(blob, encoding, function (content) {\n\t                    var boundary = getMultiPartFormBoundary(contentTypeHeader);\n\t                    var parts = boundary && includeParts ? getMultiPartFormParts(boundary, content) : [];\n\t                    content = content.slice(0, getMaxHTTPBodySize());\n\t                    var bodyMessage = {\n\t                        size: blob.size,\n\t                        encoding: encoding,\n\t                        content: content,\n\t                        isTruncated: blob.size > content.length\n\t                    };\n\t                    if (parts && includeParts) {\n\t                        bodyMessage.parts = parts;\n\t                    }\n\t                    cb(bodyMessage);\n\t                });\n\t                break;\n\t            default:\n\t                setTimeout(function () {\n\t                    return cb({\n\t                        size: blob.size,\n\t                        encoding: encoding,\n\t                        content: '',\n\t                        isTruncated: true\n\t                    });\n\t                }, 0);\n\t                break;\n\t        }\n\t    } else {\n\t        setTimeout(function () {\n\t            return cb(createEmptyBody(false));\n\t        }, 0);\n\t    }\n\t}\n\t/**\n\t * Function to convert a string to a map from header-name => string[] of header values\n\t *\n\t * @param rawHeaders raw headers string\n\t */\n\tfunction convertRawHeaders(rawHeaders) {\n\t    var h = {};\n\t    rawHeaders = rawHeaders.trim();\n\t    var lines = rawHeaders.split('\\r\\n');\n\t    lines.forEach(function (l) {\n\t        var idx = l.indexOf(':');\n\t        if (idx > 0) {\n\t            var name = l.substring(0, idx).trim().toLowerCase();\n\t            var value = l.substring(idx + 1, l.length).trim();\n\t            if (!h[name]) {\n\t                h[name] = [];\n\t            }\n\t            h[name].push(value);\n\t        }\n\t    });\n\t    return h;\n\t}\n\t/**\n\t * Regular expression to pull boundary delimiter from multipart/form-data content type.\n\t * valid boundary characters taken from grammar defined in https://www.ietf.org/rfc/rfc2046.txt, Appendix A\n\t */\n\tvar MULTIPART_FORMDATA_REG_EX = /\\s*(multipart\\/form-data)\\s*;.*boundary\\s*=\\s*\"?([0-9a-zA-Z'()+_,-.\\/:=?]+)\"?/i;\n\t/**\n\t * Get the boundary delimiter for a multipart/forma-data content-type header.\n\t * If boundary paramter doesn't exist, or if content-type is not multipart/form-data\n\t * this will return undefined;\n\t *\n\t * @param contentTypeHeader the value of the Content-Type header\n\t */\n\tfunction getMultiPartFormBoundary(contentTypeHeader) {\n\t    var matches = MULTIPART_FORMDATA_REG_EX.exec(contentTypeHeader);\n\t    if (matches) {\n\t        return matches[2];\n\t    }\n\t    return undefined;\n\t}\n\t/**\n\t * Given a multipart-form/data encoded body & a boundary delimiter, this will return an\n\t * array of IPartSummary interfaces describing the parts.\n\t *\n\t * @param boundary The boundary delimiter string used in a multipart/form-data message\n\t * @param body The text body.\n\t */\n\tfunction getMultiPartFormParts(boundary, body) {\n\t    boundary = '--' + boundary;\n\t    var firstBoundaryRegExString = '^((\\\\r\\\\n)?' + boundary + '\\\\s*?\\\\r\\\\n)';\n\t    var firstBoundaryRegEx = new RegExp(firstBoundaryRegExString, 'gm');\n\t    // captures:\n\t    //    $1:  optional header section\n\t    //    $2:  CRLFCRLF seperating headers & body, or if no headers, separating boundary marker & body\n\t    //    $3:  body section\n\t    //    $4:  next boundary marker\n\t    //    $5:  content after closing boundary\n\t    //    $6:  \"--\" indicating end of multipart bodies.  If this part matches, then we've found the last boundary delimiter\n\t    //    $7:  trailing whitespace\n\t    var partRegExString = '([\\\\s\\\\S]*?)(\\\\r\\\\n\\\\r\\\\n)([\\\\s\\\\S]*?)(\\\\r\\\\n' + boundary + ')((--)|(\\\\s*?\\\\r\\\\n))';\n\t    var partRegEx = new RegExp(partRegExString, 'gm');\n\t    var firstBoundary = firstBoundaryRegEx.exec(body);\n\t    var partSummaries = [];\n\t    if (firstBoundary) {\n\t        // start searching for parts immediately after the first boundary reg ex match.  Back up two to include trailing \\r\\n\n\t        partRegEx.lastIndex = firstBoundaryRegEx.lastIndex - 2;\n\t        while (true) {\n\t            var part = partRegEx.exec(body);\n\t            if (!part) {\n\t                break;\n\t            }\n\t            var headerSectionLength = part[1] ? part[1].length : 0;\n\t            var bodyStartIndex = part.index + headerSectionLength + part[2].length;\n\t            var convertedHeaders = part[1] ? convertRawHeaders(part[1]) : {};\n\t            var bodySectionLength = part[3] ? part[3].length : 0;\n\t            partSummaries.push({\n\t                headers: convertedHeaders,\n\t                bodyStartIndex: part.index + part[1].length + part[2].length,\n\t                bodyEndIndex: bodyStartIndex + bodySectionLength,\n\t                bodyLength: bodySectionLength\n\t            });\n\t            if (part[6]) {\n\t                // found trailing -- after boundary, which indicates we're done\n\t                break;\n\t            }\n\t        }\n\t    }\n\t    return partSummaries;\n\t}\n\t/**\n\t * Asynchronously attempts to find a PerformanceResourceTiming object that matches the given initiatorType and url and\n\t * whose startTime is within two milliseconds of `expectedStart` parameter. Specified callback will invoked with the\n\t * matching PerformanceResourceTiming object, or with undefined if unable to find matching object.\n\t * Will attempt lookup up to 8 times, with a delay increasing exponentially from 1ms up to 256ms, for a maximum delay of 511ms\n\t *\n\t * @param initiatorType A RegExp that will match the expected value for the initiatorType of the target PerformanceResourceTiming instance\n\t * @param url - expected URL of the target PerformanceResourceTiming instance\n\t * @param expectedStart - the expected start time for the target PerformanceResourceTiming instance\n\t * @param cb - callback to invoke when target is found, or when max number of lookup attempts has been made\n\t */\n\tfunction tryFindResourceTimingObject(requestId, initiatorType, url, expectedStart, cb) {\n\t    if (!(performance && performance.getEntriesByType)) {\n\t        setTimeout(function () {\n\t            return cb(undefined);\n\t        });\n\t        return;\n\t    }\n\t    var maxDelay = 1024; // milliseconds\n\t    var delay = 1;\n\t    function tryGet() {\n\t        function computeDelta(p2) {\n\t            return Math.abs(p2.startTime - expectedStart);\n\t        }\n\t        // try to find this request\n\t        var entries = performance.getEntriesByType('resource');\n\t        var target = undefined;\n\t        var candidates = [];\n\t        for (var i = 0; i < entries.length; i++) {\n\t            var curr = entries[i];\n\t            if (requestId && curr.__glimpse_requestId === requestId) {\n\t                // if we've already matched this PerformanceResourceTiming with this specific request, then use it\n\t                target = curr;\n\t                break;\n\t            } else if (initiatorType.test(curr.initiatorType) && curr.name === url && expectedStart <= curr.startTime && !curr.__glimpse_requestId) {\n\t                candidates.push(curr);\n\t            }\n\t        }\n\t        if (!target) {\n\t            candidates.sort(function (a, b) {\n\t                var deltaA = computeDelta(a);\n\t                var deltaB = computeDelta(b);\n\t                // sort by smallest delta between startTime & expectedStart\n\t                return deltaA - deltaB;\n\t            });\n\t            if (candidates.length > 0) {\n\t                target = candidates[0];\n\t                target.__glimpse_requestId = requestId;\n\t            }\n\t        }\n\t        if (target || delay >= maxDelay) {\n\t            cb(target);\n\t        } else {\n\t            delay *= 2;\n\t            setTimeout(tryGet, delay);\n\t        }\n\t        return target;\n\t    }\n\t    setTimeout(tryGet, delay);\n\t}\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar MAX_HTTP_BODY_SIZE = exports.MAX_HTTP_BODY_SIZE = 132000;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getStackTrace = getStackTrace;\n\t\n\tvar _errorStackParser = __webpack_require__(19);\n\t\n\tvar ErrorStackParser = _interopRequireWildcard(_errorStackParser);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction getStackTrace(cb) {\n\t    // stacktrace-js library has a Get method that will try to apply sourcemaps, however\n\t    // that will trigger a download of the source, and will show up as an XHR request\n\t    // in glimpse, which we don't want.  When we disable source-maps, then\n\t    // stacktrace-js will reject a promise, which causes undesired debugger breakpoints\n\t    // when the user has their app open in f12 tools. The easiest thing here is to put\n\t    // generate the error ourself, and use the error-stack-parser library to parse the\n\t    // error into stack frames.\n\t    // this logic to get an error comes from stacktrace-js library.\n\t    // See https://github.com/stacktracejs/stacktrace.js/blob/master/stacktrace.js#L25-L32\n\t    function getError() {\n\t        var err = new Error();\n\t        if (!err.stack) {\n\t            try {\n\t                // Error must be thrown to get stack in IE\n\t                throw new Error();\n\t            } catch (e2) {\n\t                err = e2;\n\t            }\n\t        }\n\t        return err;\n\t    }\n\t    var stackFrames = ErrorStackParser.parse(getError());\n\t    // slice off top frames where glimpse code is on the stack.\n\t    for (var i = 0; i < stackFrames.length; i++) {\n\t        if (stackFrames[i].fileName && !stackFrames[i].fileName.endsWith('/glimpse/agent/agent.js?hash={hash}')) {\n\t            stackFrames = stackFrames.slice(i);\n\t            break;\n\t        }\n\t    }\n\t    // strip out any extra properties we don't want to send w/ the glimpse message\n\t    var newFrames = [];\n\t    stackFrames.forEach(function (val, index) {\n\t        newFrames[index] = {\n\t            fileName: val.fileName,\n\t            functionName: val.functionName,\n\t            lineNumber: val.lineNumber,\n\t            columnNumber: val.columnNumber\n\t        };\n\t    });\n\t    // various tests are expecting this to run asynchronously, which we'll eventually need if we ever hook up\n\t    // source maps.  Even though we don't need it today, we'll leave this as an async function.\n\t    window.setTimeout(function () {\n\t        cb(newFrames);\n\t    }, 0);\n\t}\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory(require('stackframe'));\n\t    } else {\n\t        root.ErrorStackParser = factory(root.StackFrame);\n\t    }\n\t}(this, function ErrorStackParser(StackFrame) {\n\t    'use strict';\n\t\n\t    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n\t    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n\t    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\t\n\t    return {\n\t        /**\n\t         * Given an Error object, extract the most information from it.\n\t         *\n\t         * @param {Error} error object\n\t         * @return {Array} of StackFrames\n\t         */\n\t        parse: function ErrorStackParser$$parse(error) {\n\t            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n\t                return this.parseOpera(error);\n\t            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n\t                return this.parseV8OrIE(error);\n\t            } else if (error.stack) {\n\t                return this.parseFFOrSafari(error);\n\t            } else {\n\t                throw new Error('Cannot parse given Error object');\n\t            }\n\t        },\n\t\n\t        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n\t        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n\t            // Fail-fast but return locations like \"(native)\"\n\t            if (urlLike.indexOf(':') === -1) {\n\t                return [urlLike];\n\t            }\n\t\n\t            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n\t            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n\t            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n\t        },\n\t\n\t        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n\t            var filtered = error.stack.split('\\n').filter(function(line) {\n\t                return !!line.match(CHROME_IE_STACK_REGEXP);\n\t            }, this);\n\t\n\t            return filtered.map(function(line) {\n\t                if (line.indexOf('(eval ') > -1) {\n\t                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n\t                }\n\t                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionName = tokens.join(' ') || undefined;\n\t                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\t\n\t                return new StackFrame({\n\t                    functionName: functionName,\n\t                    fileName: fileName,\n\t                    lineNumber: locationParts[1],\n\t                    columnNumber: locationParts[2],\n\t                    source: line\n\t                });\n\t            }, this);\n\t        },\n\t\n\t        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n\t            var filtered = error.stack.split('\\n').filter(function(line) {\n\t                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n\t            }, this);\n\t\n\t            return filtered.map(function(line) {\n\t                // Throw away eval information until we implement stacktrace.js/stackframe#8\n\t                if (line.indexOf(' > eval') > -1) {\n\t                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n\t                }\n\t\n\t                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n\t                    // Safari eval frames only have function names and nothing else\n\t                    return new StackFrame({\n\t                        functionName: line\n\t                    });\n\t                } else {\n\t                    var tokens = line.split('@');\n\t                    var locationParts = this.extractLocation(tokens.pop());\n\t                    var functionName = tokens.join('@') || undefined;\n\t\n\t                    return new StackFrame({\n\t                        functionName: functionName,\n\t                        fileName: locationParts[0],\n\t                        lineNumber: locationParts[1],\n\t                        columnNumber: locationParts[2],\n\t                        source: line\n\t                    });\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        parseOpera: function ErrorStackParser$$parseOpera(e) {\n\t            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n\t                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n\t                return this.parseOpera9(e);\n\t            } else if (!e.stack) {\n\t                return this.parseOpera10(e);\n\t            } else {\n\t                return this.parseOpera11(e);\n\t            }\n\t        },\n\t\n\t        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n\t            var lines = e.message.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 2, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(new StackFrame({\n\t                        fileName: match[2],\n\t                        lineNumber: match[1],\n\t                        source: lines[i]\n\t                    }));\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n\t            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n\t            var lines = e.stacktrace.split('\\n');\n\t            var result = [];\n\t\n\t            for (var i = 0, len = lines.length; i < len; i += 2) {\n\t                var match = lineRE.exec(lines[i]);\n\t                if (match) {\n\t                    result.push(\n\t                        new StackFrame({\n\t                            functionName: match[3] || undefined,\n\t                            fileName: match[2],\n\t                            lineNumber: match[1],\n\t                            source: lines[i]\n\t                        })\n\t                    );\n\t                }\n\t            }\n\t\n\t            return result;\n\t        },\n\t\n\t        // Opera 10.65+ Error.stack very similar to FF/Safari\n\t        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n\t            var filtered = error.stack.split('\\n').filter(function(line) {\n\t                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n\t            }, this);\n\t\n\t            return filtered.map(function(line) {\n\t                var tokens = line.split('@');\n\t                var locationParts = this.extractLocation(tokens.pop());\n\t                var functionCall = (tokens.shift() || '');\n\t                var functionName = functionCall\n\t                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n\t                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n\t                var argsRaw;\n\t                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n\t                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n\t                }\n\t                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n\t                    undefined : argsRaw.split(',');\n\t\n\t                return new StackFrame({\n\t                    functionName: functionName,\n\t                    args: args,\n\t                    fileName: locationParts[0],\n\t                    lineNumber: locationParts[1],\n\t                    columnNumber: locationParts[2],\n\t                    source: line\n\t                });\n\t            }, this);\n\t        }\n\t    };\n\t}));\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {\n\t    'use strict';\n\t    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\t\n\t    /* istanbul ignore next */\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object') {\n\t        module.exports = factory();\n\t    } else {\n\t        root.StackFrame = factory();\n\t    }\n\t}(this, function() {\n\t    'use strict';\n\t    function _isNumber(n) {\n\t        return !isNaN(parseFloat(n)) && isFinite(n);\n\t    }\n\t\n\t    function _capitalize(str) {\n\t        return str[0].toUpperCase() + str.substring(1);\n\t    }\n\t\n\t    function _getter(p) {\n\t        return function() {\n\t            return this[p];\n\t        };\n\t    }\n\t\n\t    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n\t    var numericProps = ['columnNumber', 'lineNumber'];\n\t    var stringProps = ['fileName', 'functionName', 'source'];\n\t    var arrayProps = ['args'];\n\t\n\t    var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\t\n\t    function StackFrame(obj) {\n\t        if (obj instanceof Object) {\n\t            for (var i = 0; i < props.length; i++) {\n\t                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n\t                    this['set' + _capitalize(props[i])](obj[props[i]]);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    StackFrame.prototype = {\n\t        getArgs: function() {\n\t            return this.args;\n\t        },\n\t        setArgs: function(v) {\n\t            if (Object.prototype.toString.call(v) !== '[object Array]') {\n\t                throw new TypeError('Args must be an Array');\n\t            }\n\t            this.args = v;\n\t        },\n\t\n\t        getEvalOrigin: function() {\n\t            return this.evalOrigin;\n\t        },\n\t        setEvalOrigin: function(v) {\n\t            if (v instanceof StackFrame) {\n\t                this.evalOrigin = v;\n\t            } else if (v instanceof Object) {\n\t                this.evalOrigin = new StackFrame(v);\n\t            } else {\n\t                throw new TypeError('Eval Origin must be an Object or StackFrame');\n\t            }\n\t        },\n\t\n\t        toString: function() {\n\t            var functionName = this.getFunctionName() || '{anonymous}';\n\t            var args = '(' + (this.getArgs() || []).join(',') + ')';\n\t            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n\t            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n\t            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n\t            return functionName + args + fileName + lineNumber + columnNumber;\n\t        }\n\t    };\n\t\n\t    for (var i = 0; i < booleanProps.length; i++) {\n\t        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\t        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {\n\t            return function(v) {\n\t                this[p] = Boolean(v);\n\t            };\n\t        })(booleanProps[i]);\n\t    }\n\t\n\t    for (var j = 0; j < numericProps.length; j++) {\n\t        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\t        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {\n\t            return function(v) {\n\t                if (!_isNumber(v)) {\n\t                    throw new TypeError(p + ' must be a Number');\n\t                }\n\t                this[p] = Number(v);\n\t            };\n\t        })(numericProps[j]);\n\t    }\n\t\n\t    for (var k = 0; k < stringProps.length; k++) {\n\t        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\t        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {\n\t            return function(v) {\n\t                this[p] = String(v);\n\t            };\n\t        })(stringProps[k]);\n\t    }\n\t\n\t    return StackFrame;\n\t}));\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.FetchInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _GlimpseLogger = __webpack_require__(8);\n\t\n\tvar _GlimpseLogger2 = _interopRequireDefault(_GlimpseLogger);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _FetchProxy = __webpack_require__(22);\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _DateTimeUtilities = __webpack_require__(11);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _HttpRequestUtils = __webpack_require__(16);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar FetchInspector = exports.FetchInspector = function () {\n\t    function FetchInspector() {\n\t        _classCallCheck(this, FetchInspector);\n\t\n\t        this.initiatorRexExp = /(^$)|(other)/i;\n\t        this.requests = {};\n\t    }\n\t\n\t    _createClass(FetchInspector, [{\n\t        key: 'createHeaders',\n\t        value: function createHeaders(headers) {\n\t            var parsedHeaders = {};\n\t            var headerKeys = (0, _RequestUtilities.getHeaderKeys)(headers);\n\t            var _iteratorNormalCompletion = true;\n\t            var _didIteratorError = false;\n\t            var _iteratorError = undefined;\n\t\n\t            try {\n\t                for (var _iterator = headerKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                    var header = _step.value;\n\t\n\t                    parsedHeaders[header] = headers.get(header);\n\t                }\n\t            } catch (err) {\n\t                _didIteratorError = true;\n\t                _iteratorError = err;\n\t            } finally {\n\t                try {\n\t                    if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                        _iterator['return']();\n\t                    }\n\t                } finally {\n\t                    if (_didIteratorError) {\n\t                        throw _iteratorError;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return parsedHeaders;\n\t        }\n\t    }, {\n\t        key: 'getContentTypeHeader',\n\t        value: function getContentTypeHeader(headers) {\n\t            var val = void 0;\n\t            val = headers.get('content-type');\n\t            if (!val) {\n\t                var headerKeys = (0, _RequestUtilities.getHeaderKeys)(headers);\n\t                var _iteratorNormalCompletion2 = true;\n\t                var _didIteratorError2 = false;\n\t                var _iteratorError2 = undefined;\n\t\n\t                try {\n\t                    for (var _iterator2 = headerKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                        var header = _step2.value;\n\t\n\t                        if (header.toLowerCase() === 'content-type') {\n\t                            val = headers[header];\n\t                            break;\n\t                        }\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError2 = true;\n\t                    _iteratorError2 = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n\t                            _iterator2['return']();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError2) {\n\t                            throw _iteratorError2;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return val;\n\t        }\n\t    }, {\n\t        key: 'before',\n\t        value: function before(event) {\n\t            var _this = this;\n\t\n\t            var eventData = event.data;\n\t            (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                var publishMessage = function publishMessage(body) {\n\t                    var url = (0, _RequestUtilities.parseUrl)(eventData.request.url);\n\t                    var startTime = (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp));\n\t                    var msg = _this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n\t                        correlationId: eventData.id,\n\t                        protocol: {\n\t                            identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n\t                        },\n\t                        url: eventData.request.url,\n\t                        method: eventData.request.method,\n\t                        startTime: startTime,\n\t                        timing: {\n\t                            startTime: 0\n\t                        },\n\t                        headers: _this.createHeaders(eventData.request.headers),\n\t                        isAjax: true,\n\t                        body: body,\n\t                        frames: frames.slice(0, 1)\n\t                    });\n\t                    (0, _MessageMixins.addOffset)(event.offset, msg);\n\t                    _this.messagePublisher.publishMessage(msg);\n\t                };\n\t                eventData.request.blob().then(function (blob) {\n\t                    var contentTypeHeader = _this.getContentTypeHeader(eventData.request.headers);\n\t                    (0, _HttpRequestUtils.createBodyForBlob)(contentTypeHeader, blob, true, function (body) {\n\t                        publishMessage(body);\n\t                    });\n\t                }, function (reason) {\n\t                    // Safari 10.1 fails to obtain the request body as a blob, so publish the message with a \"truncated\" body...\n\t                    // (https://github.com/Glimpse/Glimpse.Browser.Agent/issues/192)\n\t                    publishMessage((0, _HttpRequestUtils.createEmptyBody)( /* truncated: */true));\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'after',\n\t        value: function after(event, requestEntry) {\n\t            var _this2 = this;\n\t\n\t            var eventData = event.data;\n\t            eventData.response.blob().then(function (blob) {\n\t                var responseEndOffset = performance.now();\n\t                // for fetch events, the initiator type is an empty string on chrome, and 'other' on firefox.\n\t                (0, _HttpRequestUtils.tryFindResourceTimingObject)(event.data.id, _this2.initiatorRexExp, event.data.response.url, requestEntry.startTimeOffset, function (timings) {\n\t                    // we make a best-effort to find the PerformanceResourceTiming instance associated with this request.  If we have one,\n\t                    // we use it, but if not, we fall back to using times associated with when different proxy methods were invoked\n\t                    var offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n\t                    var startTime = 0;\n\t                    // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n\t                    var responseStart = timings && timings.responseStart >= timings.startTime ? timings.responseStart - timings.startTime : undefined;\n\t                    var responseEnd = timings ? timings.responseEnd - timings.startTime : responseEndOffset - requestEntry.startTimeOffset;\n\t                    var contentTypeHeader = _this2.getContentTypeHeader(eventData.response.headers);\n\t                    (0, _HttpRequestUtils.createBodyForBlob)(contentTypeHeader, blob, true, function (body) {\n\t                        var statusCode = void 0;\n\t                        switch (eventData.response.type) {\n\t                            case 'error':\n\t                                // TODO: publish an error message here. See https://github.com/Glimpse/Glimpse.Browser.Agent/issues/134\n\t                                return;\n\t                            case 'opaque':\n\t                                statusCode = -1;\n\t                                break;\n\t                            case 'opaqueredirect':\n\t                                statusCode = -2;\n\t                                break;\n\t                            default:\n\t                                statusCode = eventData.response.status;\n\t                                break;\n\t                        }\n\t                        var msg = _this2.messagePublisher.createMessage('data-http-response', {\n\t                            correlationId: eventData.id,\n\t                            url: eventData.response.url,\n\t                            headers: _this2.createHeaders(eventData.response.headers),\n\t                            statusCode: statusCode,\n\t                            statusMessage: eventData.response.statusText,\n\t                            endTime: (0, _DateTimeUtilities.getDateTime)(new Date(event.timeStamp)),\n\t                            duration: responseEnd,\n\t                            timing: {\n\t                                startTime: startTime,\n\t                                responseEnd: responseEnd\n\t                            },\n\t                            body: body\n\t                        });\n\t                        if (responseStart !== undefined) {\n\t                            msg.payload.timing.responseStart = responseStart;\n\t                        }\n\t                        (0, _MessageMixins.addOffset)(offset, msg);\n\t                        _this2.messagePublisher.publishMessage(msg);\n\t                    });\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'numOutstandingRequests',\n\t        value: function numOutstandingRequests() {\n\t            return Object.keys(this.requests).length;\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this3 = this;\n\t\n\t            this.messagePublisher = messagePublisher;\n\t            _Tracing2['default'].on(_FetchProxy.EVENT_FETCH_REQUEST_SENT, function (event) {\n\t                _this3.requests[event.data.id] = {\n\t                    startTimeStamp: event.timeStamp,\n\t                    startTimeOffset: event.offset\n\t                };\n\t                _this3.before(event);\n\t            });\n\t            _Tracing2['default'].on(_FetchProxy.EVENT_FETCH_RESPONSE_RECEIVED, function (event) {\n\t                var requestEntry = _this3.requests[event.data.id];\n\t                if (!requestEntry) {\n\t                    _GlimpseLogger2['default'].error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n\t                    return;\n\t                }\n\t                _this3.after(event, requestEntry);\n\t                delete _this3.requests[event.data.id];\n\t            });\n\t            _Tracing2['default'].on(_FetchProxy.EVENT_FETCH_ERROR, function (data) {\n\t                delete _this3.requests[data.data.id];\n\t            });\n\t        }\n\t    }]);\n\n\t    return FetchInspector;\n\t}();\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.FetchProxy = exports.EVENT_FETCH_ERROR = exports.EVENT_FETCH_RESPONSE_RECEIVED = exports.EVENT_FETCH_REQUEST_SENT = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_FETCH_REQUEST_SENT = exports.EVENT_FETCH_REQUEST_SENT = 'invoke|pre|fetch.request-sent';\n\tvar EVENT_FETCH_RESPONSE_RECEIVED = exports.EVENT_FETCH_RESPONSE_RECEIVED = 'notify|fetch.response-received';\n\tvar EVENT_FETCH_ERROR = exports.EVENT_FETCH_ERROR = 'notify|fetch.error';\n\t/**\n\t * Proxy which wraps fetch usage and its various supporting functions.\n\t *\n\t * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n\t */\n\t\n\tvar FetchProxy = exports.FetchProxy = function () {\n\t    function FetchProxy() {\n\t        _classCallCheck(this, FetchProxy);\n\t    }\n\t\n\t    _createClass(FetchProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            return !!(self && typeof self.fetch !== 'undefined');\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            // Note: we use `self` instead of `window` in case we're in a worker thread\n\t            // See https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n\t            // Only initialize if this browser supports the Fetch API\n\t            if (self.fetch) {\n\t                var oldFetch = self.fetch;\n\t                self.fetch = function fetch(input, init) {\n\t                    // Create a request object if one wasn't specified, or clone the\n\t                    // existing one if it was so we can safely read the body.\n\t                    var request = void 0;\n\t\n\t                    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t                        args[_key - 2] = arguments[_key];\n\t                    }\n\t\n\t                    if (input instanceof Request) {\n\t                        request = input.clone();\n\t                    } else {\n\t                        // OK, so I know this looks weird, but the use of Promises\n\t                        // here provides a unique challenge. If you instantiate a\n\t                        // Request object directly, it will throw an exception if the\n\t                        // input is malformed. However, the `fetch()` API is wrapped\n\t                        // in a promise, which means malformed input does _not_ throw\n\t                        // when passed to `fetch()`. Instead it causes the promise to\n\t                        // reject. We do _not_ want to pick up on this case though,\n\t                        // because we would otherwise publish an ERROR_EVENT, which\n\t                        // we do _not_ want in this case. So we detect malformed input,\n\t                        // and return the promise directly without listening to it.\n\t                        try {\n\t                            request = new Request(input, init);\n\t                        } catch (e) {\n\t                            return oldFetch.call.apply(oldFetch, [this, input, init].concat(args));\n\t                        }\n\t                    }\n\t                    var id = (0, _GeneralUtilities.getGuid)();\n\t                    // Publish the request message\n\t                    var requestSentEventData = {\n\t                        id: id,\n\t                        request: request\n\t                    };\n\t                    _Tracing2['default'].publish(EVENT_FETCH_REQUEST_SENT, requestSentEventData);\n\t                    // Call the original fetch method. We wait for the response to be\n\t                    // received using the promise, and publish the resulting\n\t                    var fetchPromise = oldFetch.call.apply(oldFetch, [this, input, init].concat(args));\n\t                    fetchPromise.then(function (response) {\n\t                        var responseReceivedEventData = {\n\t                            id: id,\n\t                            response: response.clone()\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_FETCH_RESPONSE_RECEIVED, responseReceivedEventData);\n\t                    }, function (error) {\n\t                        var errorEventData = {\n\t                            id: id,\n\t                            error: error\n\t                        };\n\t                        _Tracing2['default'].publish(EVENT_FETCH_ERROR, errorEventData);\n\t                    });\n\t                    return fetchPromise;\n\t                };\n\t            }\n\t        }\n\t    }]);\n\n\t    return FetchProxy;\n\t}();\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ResourceTimingInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ResourceTimingProxy = __webpack_require__(24);\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ResourceTimingInspector = exports.ResourceTimingInspector = function () {\n\t    function ResourceTimingInspector() {\n\t        _classCallCheck(this, ResourceTimingInspector);\n\t    }\n\t\n\t    _createClass(ResourceTimingInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            _Tracing2['default'].on(_ResourceTimingProxy.EVENT_RESOURCE_TIMING_COLLECTED, function (event) {\n\t                // TODO: Eventually, we'll add more logic here to clean up data in\n\t                // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n\t                messagePublisher.createAndPublishMessage('browser-resource', {\n\t                    timings: event.data\n\t                });\n\t            });\n\t        }\n\t    }]);\n\n\t    return ResourceTimingInspector;\n\t}();\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ResourceTimingProxy = exports.EVENT_RESOURCE_TIMING_COLLECTED = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tvar _PerformanceUtilities = __webpack_require__(25);\n\t\n\tvar _PerformanceUtilities2 = _interopRequireDefault(_PerformanceUtilities);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar UPDATE_INTERVAL = 1000;\n\tvar EVENT_RESOURCE_TIMING_COLLECTED = exports.EVENT_RESOURCE_TIMING_COLLECTED = 'notify|performance.resource-collected';\n\t\n\tvar ResourceTimingProxy = exports.ResourceTimingProxy = function () {\n\t    function ResourceTimingProxy() {\n\t        _classCallCheck(this, ResourceTimingProxy);\n\t    }\n\t\n\t    _createClass(ResourceTimingProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            // Don't initialize if this browser doesn't support resource timing\n\t            return !!(_PerformanceUtilities2['default'] && _PerformanceUtilities2['default'].getEntriesByType);\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            function processEntry(entry) {\n\t                // This sheds any extra properties that may be introduced to resource timing\n\t                // or are browser specific, and ensures the data matches our interface for it.\n\t                return {\n\t                    name: entry.name,\n\t                    startTime: entry.startTime,\n\t                    duration: entry.duration,\n\t                    initiatorType: entry.initiatorType,\n\t                    nextHopProtocol: entry.nextHopProtocol,\n\t                    redirectStart: entry.redirectStart,\n\t                    redirectEnd: entry.redirectEnd,\n\t                    fetchStart: entry.fetchStart,\n\t                    domainLookupStart: entry.domainLookupStart,\n\t                    domainLookupEnd: entry.domainLookupEnd,\n\t                    connectStart: entry.connectStart,\n\t                    connectEnd: entry.connectEnd,\n\t                    secureConnectionStart: entry.secureConnectionStart,\n\t                    requestStart: entry.requestStart,\n\t                    responseStart: entry.responseStart,\n\t                    responseEnd: entry.responseEnd,\n\t                    transferSize: entry.transferSize,\n\t                    encodedBodySize: entry.encodedBodySize,\n\t                    decodedBodySize: entry.decodedBodySize\n\t                };\n\t            }\n\t            // Eventually we want to switch to using Performance Observers once browsers\n\t            // start to implement, but currently none do, so we poll for entries instead\n\t            // https://w3c.github.io/performance-timeline/#dom-performanceobserver\n\t            var reportedEntries = {};\n\t            function record() {\n\t                var resources = _PerformanceUtilities2['default'].getEntriesByType('resource');\n\t                var entriesToPublish = [];\n\t                var ingressUrl = (0, _RequestUtilities.getMessageIngressUrl)();\n\t                var _iteratorNormalCompletion = true;\n\t                var _didIteratorError = false;\n\t                var _iteratorError = undefined;\n\t\n\t                try {\n\t                    for (var _iterator = resources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t                        var resource = _step.value;\n\t\n\t                        // Create a unique id for the entry, a combination of the start time\n\t                        // and resolved URL\n\t                        var id = resource.startTime + '#' + resource.name;\n\t                        if (!reportedEntries[id] && resource.name.indexOf(ingressUrl) === -1) {\n\t                            reportedEntries[id] = true;\n\t                            entriesToPublish.push(processEntry(resource));\n\t                        }\n\t                    }\n\t                } catch (err) {\n\t                    _didIteratorError = true;\n\t                    _iteratorError = err;\n\t                } finally {\n\t                    try {\n\t                        if (!_iteratorNormalCompletion && _iterator['return']) {\n\t                            _iterator['return']();\n\t                        }\n\t                    } finally {\n\t                        if (_didIteratorError) {\n\t                            throw _iteratorError;\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (entriesToPublish.length) {\n\t                    _Tracing2['default'].publish(EVENT_RESOURCE_TIMING_COLLECTED, entriesToPublish);\n\t                }\n\t                setTimeout(record, UPDATE_INTERVAL);\n\t            }\n\t            ;\n\t            record();\n\t        }\n\t    }]);\n\n\t    return ResourceTimingProxy;\n\t}();\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tfunction getPerformance() {\n\t    // tslint:disable:no-any\n\t    return window.performance || window.webkitPerformance || window.msPerformance || window.mozPerformance;\n\t}\n\texports[\"default\"] = getPerformance();\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.NavigationTimingInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _NavigationTimingProxy = __webpack_require__(27);\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NavigationTimingInspector = exports.NavigationTimingInspector = function () {\n\t    function NavigationTimingInspector() {\n\t        _classCallCheck(this, NavigationTimingInspector);\n\t    }\n\t\n\t    _createClass(NavigationTimingInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            _Tracing2['default'].on(_NavigationTimingProxy.EVENT_NAVIGATION_TIMING_COLLECTED, function (event) {\n\t                var data = event.data;\n\t                var message = Object.assign({ loadDuration: data.loadEventEnd - data.fetchStart,\n\t                    // time spent constructing the DOM tree\n\t                    domReadyDuration: data.domComplete - data.domInteractive,\n\t                    // time consumed preparing the new page\n\t                    readyStartDuration: data.fetchStart - data.navigationStart,\n\t                    // time spent during redirection\n\t                    redirectDuration: data.redirectEnd - data.redirectStart,\n\t                    // appCache\n\t                    appcacheDuration: data.domainLookupStart - data.fetchStart,\n\t                    // time spent unloading documents\n\t                    unloadEventDuration: data.unloadEventEnd - data.unloadEventStart,\n\t                    // DNS query time\n\t                    lookupDomainDuration: data.domainLookupEnd - data.domainLookupStart,\n\t                    // TCP connection time\n\t                    connectDuration: data.connectEnd - data.connectStart,\n\t                    // time spent during the request\n\t                    requestDuration: data.responseEnd - data.requestStart,\n\t                    // request to completion of the DOM loading\n\t                    initDomTreeDuration: data.domInteractive - data.responseEnd,\n\t                    // load event time\n\t                    loadEventDuration: data.loadEventEnd - data.loadEventStart,\n\t                    // time spent on the network making the outgoing request\n\t                    networkRequestDuration: data.requestStart - data.navigationStart,\n\t                    // time spent on the network receiving the incoming response\n\t                    networkResponseDuration: data.responseEnd - data.responseStart,\n\t                    // time spent on the server processing the request\n\t                    serverDuration: data.responseEnd - data.requestStart,\n\t                    // time spent on the browser handling the response\n\t                    browserDuration: data.loadEventEnd - data.responseStart,\n\t                    // total time\n\t                    totalDuration: data.loadEventEnd - data.navigationStart }, event.data);\n\t                // time spent on the network for the whole request/response\n\t                message.networkDuration = message.networkRequestDuration + message.networkResponseDuration;\n\t                // TODO: Eventually, we'll add more logic here to clean up data in\n\t                // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n\t                messagePublisher.createAndPublishMessage('browser-navigation-timing', message);\n\t            });\n\t        }\n\t    }]);\n\n\t    return NavigationTimingInspector;\n\t}();\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.NavigationTimingProxy = exports.EVENT_NAVIGATION_TIMING_COLLECTED = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _PerformanceUtilities = __webpack_require__(25);\n\t\n\tvar _PerformanceUtilities2 = _interopRequireDefault(_PerformanceUtilities);\n\t\n\tvar _RequestUtilities = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_NAVIGATION_TIMING_COLLECTED = exports.EVENT_NAVIGATION_TIMING_COLLECTED = 'notify|performance.navigation-timing';\n\t\n\tvar NavigationTimingProxy = exports.NavigationTimingProxy = function () {\n\t    function NavigationTimingProxy() {\n\t        _classCallCheck(this, NavigationTimingProxy);\n\t    }\n\t\n\t    _createClass(NavigationTimingProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            return !!(_PerformanceUtilities2['default'] && _PerformanceUtilities2['default'].timing);\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            var _this = this;\n\t\n\t            // setup/regiter strategy to run later\n\t            (0, _RequestUtilities.addEvent)(window, 'load', function () {\n\t                setTimeout(function () {\n\t                    _this.processTimings(_PerformanceUtilities2['default'].timing);\n\t                });\n\t            });\n\t        }\n\t    }, {\n\t        key: 'processEntry',\n\t        value: function processEntry(entry) {\n\t            // This sheds any extra properties that may be introduced to navigation\n\t            // timing or are browser specific, and ensures the data matches our\n\t            // interface for it.\n\t            return {\n\t                connectEnd: entry.connectEnd,\n\t                connectStart: entry.connectStart,\n\t                domComplete: entry.domComplete,\n\t                domContentLoadedEventEnd: entry.domContentLoadedEventEnd,\n\t                domContentLoadedEventStart: entry.domContentLoadedEventStart,\n\t                domInteractive: entry.domInteractive,\n\t                domLoading: entry.domLoading,\n\t                domainLookupEnd: entry.domainLookupEnd,\n\t                domainLookupStart: entry.domainLookupStart,\n\t                fetchStart: entry.fetchStart,\n\t                firstPaint: entry.firstPaint,\n\t                firstPaintDuration: 0,\n\t                loadEventEnd: entry.loadEventEnd,\n\t                loadEventStart: entry.loadEventStart,\n\t                navigationStart: entry.navigationStart,\n\t                redirectEnd: entry.redirectEnd,\n\t                redirectStart: entry.redirectStart,\n\t                requestStart: entry.requestStart,\n\t                responseEnd: entry.responseEnd,\n\t                responseStart: entry.responseStart,\n\t                // NOTE: Firefox and Edge will not always provide a value for secureConnectionStart.\n\t                secureConnectionStart: entry.secureConnectionStart || 0,\n\t                unloadEventEnd: entry.unloadEventEnd,\n\t                unloadEventStart: entry.unloadEventStart\n\t            };\n\t        }\n\t    }, {\n\t        key: 'processTimings',\n\t        value: function processTimings(timing) {\n\t            var eventData = this.processEntry(timing);\n\t            // time to first paint\n\t            // tslint:disable-next-line:no-any\n\t            if (eventData.firstPaint === undefined) {\n\t                // All times are relative times to the start time within the\n\t                // same objects\n\t                var firstPaint = 0;\n\t                var firstPaintDuration = 0;\n\t                //tslint:disable-next-line:no-any\n\t                if (window.chrome && window.chrome.loadTimes) {\n\t                    //tslint:disable-next-line:no-any\n\t                    var loadTimes = window.chrome.loadTimes();\n\t                    firstPaint = loadTimes.firstPaintTime * 1000;\n\t                    firstPaintDuration = firstPaint - loadTimes.startLoadTime * 1000;\n\t                } else if (typeof timing.msFirstPaint === 'number') {\n\t                    firstPaint = timing.msFirstPaint;\n\t                    firstPaintDuration = firstPaint - timing.navigationStart;\n\t                }\n\t                eventData.firstPaint = firstPaint;\n\t                eventData.firstPaintDuration = firstPaintDuration;\n\t            }\n\t            _Tracing2['default'].publish(EVENT_NAVIGATION_TIMING_COLLECTED, eventData);\n\t        }\n\t    }]);\n\n\t    return NavigationTimingProxy;\n\t}();\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ConsoleInspector = exports.LogMessageTypes = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _ConsoleProxy = __webpack_require__(29);\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar LogMessageTypes = exports.LogMessageTypes = undefined;\n\t(function (LogMessageTypes) {\n\t    LogMessageTypes[LogMessageTypes[\"json\"] = 0] = \"json\";\n\t    LogMessageTypes[LogMessageTypes[\"xml\"] = 1] = \"xml\";\n\t    LogMessageTypes[LogMessageTypes[\"table\"] = 2] = \"table\";\n\t    LogMessageTypes[LogMessageTypes[\"assert\"] = 3] = \"assert\";\n\t    LogMessageTypes[LogMessageTypes[\"count\"] = 4] = \"count\";\n\t    LogMessageTypes[LogMessageTypes[\"timespan_begin\"] = 5] = \"timespan_begin\";\n\t    LogMessageTypes[LogMessageTypes[\"timespan_end\"] = 6] = \"timespan_end\";\n\t    LogMessageTypes[LogMessageTypes[\"group_begin\"] = 7] = \"group_begin\";\n\t    LogMessageTypes[LogMessageTypes[\"group_end\"] = 8] = \"group_end\";\n\t})(LogMessageTypes || (exports.LogMessageTypes = LogMessageTypes = {}));\n\t\n\tvar ConsoleInspector = exports.ConsoleInspector = function () {\n\t    function ConsoleInspector() {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, ConsoleInspector);\n\t\n\t        this.countMap = {};\n\t        this.stack = {\n\t            group: [],\n\t            profile: []\n\t        };\n\t        this.map = {\n\t            time: {}\n\t        };\n\t        this.mapNull = {\n\t            time: undefined\n\t        };\n\t        this.methods = {\n\t            assert: {\n\t                level: 'Error',\n\t                processor: function processor(message, data) {\n\t                    return _this.assert(message, data);\n\t                }\n\t            },\n\t            count: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.count(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            debug: {\n\t                level: 'Debug',\n\t                nullByPass: true\n\t            },\n\t            dir: {\n\t                level: 'Log',\n\t                nullByPass: true,\n\t                processor: function processor(message, data) {\n\t                    return _this.dir(message, data, LogMessageTypes.json);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            dirxml: {\n\t                level: 'Log',\n\t                nullByPass: true,\n\t                processor: function processor(message, data) {\n\t                    return _this.dir(message, data, LogMessageTypes.xml);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            error: {\n\t                level: 'Error',\n\t                nullByPass: true\n\t            },\n\t            group: {\n\t                level: undefined,\n\t                processor: function processor(message, data) {\n\t                    return _this.groupStart(message, data, false);\n\t                }\n\t            },\n\t            groupCollapsed: {\n\t                level: undefined,\n\t                processor: function processor(message, data) {\n\t                    return _this.groupStart(message, data, true);\n\t                }\n\t            },\n\t            groupEnd: {\n\t                level: undefined,\n\t                processor: function processor(message, data) {\n\t                    return _this.groupEnd(message, data);\n\t                }\n\t            },\n\t            info: {\n\t                level: 'Info',\n\t                nullByPass: true\n\t            },\n\t            log: {\n\t                level: 'Log',\n\t                nullByPass: true\n\t            },\n\t            profile: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.profileStart(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            profileEnd: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.profileEnd(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            table: {\n\t                level: 'Log',\n\t                nullByPass: true,\n\t                processor: function processor(message, data) {\n\t                    return _this.applyType(message, data, LogMessageTypes.table);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            time: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.mapStart('time', message, data, LogMessageTypes.timespan_begin);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            timeEnd: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.mapEnd('time', message, data, LogMessageTypes.timespan_end);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            timeStamp: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.timeStamp(message, data);\n\t                },\n\t                tokenTypeByPass: true\n\t            },\n\t            trace: {\n\t                level: 'Debug',\n\t                processor: function processor(message, data) {\n\t                    return _this.trace(message, data);\n\t                }\n\t            },\n\t            warn: {\n\t                level: 'Warning',\n\t                nullByPass: true\n\t            }\n\t        };\n\t    }\n\t\n\t    _createClass(ConsoleInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this2 = this;\n\t\n\t            _Tracing2['default'].on(_ConsoleProxy.NOTIFY_CONSOLE_EVENT_OCCURED, function (event) {\n\t                var data = event.data;\n\t                var payload = {\n\t                    method: data.method,\n\t                    arguments: data.arguments,\n\t                    offset: event.offset\n\t                };\n\t                _this2.publishMessage(messagePublisher, payload);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'publishMessage',\n\t        value: function publishMessage(messagePublisher, data) {\n\t            var info = this.methods[data.method];\n\t            // in the case where we have no args or a nullByPass is in effect then we shouldn't log messages\n\t            if (!data.arguments || data.arguments.constructor !== Array || info.nullByPass && data.arguments.length === 0) {\n\t                return;\n\t            }\n\t            // build base message\n\t            var payload = {\n\t                message: data.arguments,\n\t                library: 'Browser Console',\n\t                level: info.level\n\t            };\n\t            var message = messagePublisher.createMessage('log-write', payload);\n\t            (0, _MessageMixins.addOffset)(data.offset, message);\n\t            // run through any custom processors\n\t            var suppressMessage = false;\n\t            if (info.processor) {\n\t                suppressMessage = info.processor(message, data) || false;\n\t            }\n\t            // normalize token format\n\t            if (!info.tokenTypeByPass) {\n\t                this.deriveTokenType(message);\n\t            }\n\t            if (!suppressMessage) {\n\t                (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                    message.payload.frames = frames;\n\t                    message.types.push('call-stack');\n\t                    messagePublisher.publishMessage(message);\n\t                });\n\t            }\n\t        }\n\t        // api specific targets\n\t\n\t    }, {\n\t        key: 'count',\n\t        value: function count(message, data) {\n\t            // chrome treats no args the same as ''\n\t            var label = data.arguments.length > 0 ? String(data.arguments[0]) : '';\n\t            // for record the label\n\t            message.payload.message = label;\n\t            // track ongoing progress\n\t            var currentCount = (this.countMap[label] || 0) + 1;\n\t            this.countMap[label] = currentCount;\n\t            // record the applyType\n\t            this.applyType(message, data, LogMessageTypes.count);\n\t            // record the addition count data\n\t            message.payload.count = currentCount;\n\t        }\n\t    }, {\n\t        key: 'assert',\n\t        value: function assert(message, data) {\n\t            var assertion = data.arguments.length > 0 ? data.arguments[0] : false;\n\t            // if we have no args|null|undefined|0 we will treat it as a fail\n\t            if (assertion) {\n\t                return true;\n\t            } else {\n\t                message.payload.message = message.payload.message.slice(1);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'dir',\n\t        value: function dir(message, data, type) {\n\t            var newArgs = data.arguments.length > 0 ? [data.arguments[0]] : data.arguments; // tslint:disable-line:no-any\n\t            var processAsDir = false;\n\t            var value = newArgs[0];\n\t            if (type === LogMessageTypes.xml && value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.getElementsByTagName && 'outerHTML' in value) {\n\t                var nodeCount = value.getElementsByTagName('*').length;\n\t                // Safety checks to deal with large data payloads\n\t                if (nodeCount > 100) {\n\t                    newArgs = 'Node with more than `100` decendents aren\\'t supported.';\n\t                } else {\n\t                    value = value.outerHTML;\n\t                    if (value.length > 2500) {\n\t                        newArgs = 'Node with more than `2500` characters aren\\'t supported.';\n\t                    } else {\n\t                        newArgs[0] = value;\n\t                    }\n\t                }\n\t                processAsDir = true;\n\t            } else if (type === LogMessageTypes.json) {\n\t                processAsDir = true;\n\t            }\n\t            // this is setup this way so that in non valid `LogMessageTypes.xml` cases, we essentually\n\t            // treat it as plain console.log\n\t            if (processAsDir) {\n\t                // we only care about the first arg in this case\n\t                message.payload.message = newArgs;\n\t                this.applyType(message, data, type);\n\t            } else {\n\t                this.deriveTokenType(message);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'timeStamp',\n\t        value: function timeStamp(message, data) {\n\t            this.getAndApplyLabel(message, data);\n\t        }\n\t    }, {\n\t        key: 'groupStart',\n\t        value: function groupStart(message, data, isCollapsed) {\n\t            message.payload.isCollapsed = isCollapsed;\n\t            this.stackStart('group', message, data, LogMessageTypes.group_begin);\n\t        }\n\t    }, {\n\t        key: 'groupEnd',\n\t        value: function groupEnd(message, data) {\n\t            return this.stackEnd('group', message, data, LogMessageTypes.group_end);\n\t        }\n\t    }, {\n\t        key: 'profileStart',\n\t        value: function profileStart(message, data) {\n\t            this.getAndApplyLabel(message, data);\n\t            this.stackStart('profile', message, data, LogMessageTypes.timespan_begin);\n\t        }\n\t    }, {\n\t        key: 'profileEnd',\n\t        value: function profileEnd(message, data) {\n\t            this.getAndApplyLabel(message, data);\n\t            var result = this.stackEnd('profile', message, data, LogMessageTypes.timespan_end);\n\t            return result;\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(message, data) {\n\t            // for trace methods include 'log-display-callstack' message type so callstack will be displayed\n\t            message.types.push('log-display-callstack');\n\t            // make a copy of the message since we're going to modify it.\n\t            message.payload.message = Array.prototype.slice.call(message.payload.message, 0);\n\t            if (message.payload.message[0] === undefined) {\n\t                message.payload.message[0] = 'Trace:';\n\t            } else {\n\t                message.payload.message[0] = 'Trace: ' + message.payload.message[0];\n\t            }\n\t        }\n\t        // common/shared helpers\n\t\n\t    }, {\n\t        key: 'applyType',\n\t        value: function applyType(message, data, mixin) {\n\t            var type = LogMessageTypes[mixin].replace('_', '-');\n\t            message.types.push('log-' + type);\n\t        }\n\t    }, {\n\t        key: 'getAndApplyLabel',\n\t        value: function getAndApplyLabel(message, data) {\n\t            var label = data.arguments.length > 0 ? String(data.arguments[0]) : undefined;\n\t            // for mapEnds we dump the args and just use the label\n\t            message.payload.message = label;\n\t            return label;\n\t        }\n\t    }, {\n\t        key: 'stackStart',\n\t        value: function stackStart(type, message, data, mixin) {\n\t            var group = this.coreStart(message, data, mixin);\n\t            this.stack[type].push(group);\n\t        }\n\t    }, {\n\t        key: 'stackEnd',\n\t        value: function stackEnd(type, message, data, mixin) {\n\t            var group = this.stack[type].pop();\n\t            if (group) {\n\t                this.coreEnd(group, message, data, mixin);\n\t            } else {\n\t                return true;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'mapStart',\n\t        value: function mapStart(type, message, data, mixin) {\n\t            var label = this.getAndApplyLabel(message, data);\n\t            var group = this.coreStart(message, data, mixin);\n\t            if (label !== undefined) {\n\t                this.map[type][label] = group;\n\t            } else {\n\t                this.mapNull[type] = group;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'mapEnd',\n\t        value: function mapEnd(type, message, data, mixin) {\n\t            var label = this.getAndApplyLabel(message, data);\n\t            var group = label !== undefined ? this.map[type][label] : this.mapNull[type];\n\t            if (group) {\n\t                if (label !== undefined) {\n\t                    delete this.map[type][label];\n\t                } else {\n\t                    this.mapNull[type] = undefined;\n\t                }\n\t            } else {\n\t                // if no match is found we should match to page load\n\t                group = { correlationId: (0, _GeneralUtilities.getGuid)(), time: 0 };\n\t            }\n\t            this.coreEnd(group, message, data, mixin);\n\t        }\n\t    }, {\n\t        key: 'coreStart',\n\t        value: function coreStart(message, data, mixin) {\n\t            var correlationId = (0, _GeneralUtilities.getGuid)();\n\t            var time = data.offset;\n\t            (0, _MessageMixins.addCorrelationBegin)(correlationId, message);\n\t            // add action begin specific data\n\t            this.applyType(message, data, mixin);\n\t            return {\n\t                correlationId: correlationId,\n\t                time: time\n\t            };\n\t        }\n\t    }, {\n\t        key: 'coreEnd',\n\t        value: function coreEnd(group, message, data, mixin) {\n\t            var time = data.offset;\n\t            // add action begin specific data\n\t            this.applyType(message, data, mixin);\n\t            (0, _MessageMixins.addCorrelationEnd)(group.correlationId, time - group.time, message);\n\t        }\n\t    }, {\n\t        key: 'deriveTokenType',\n\t        value: function deriveTokenType(message) {\n\t            if (message.payload.message !== undefined && message.payload.message !== null // tslint:disable-line:no-null-keyword\n\t            && message.payload.message !== 'string') {\n\t                message.types.push('log-token-printf');\n\t                message.payload.tokenSupport = 'browser';\n\t            }\n\t        }\n\t    }]);\n\n\t    return ConsoleInspector;\n\t}();\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ConsoleProxy = exports.NOTIFY_CONSOLE_EVENT_OCCURED = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar NOTIFY_CONSOLE_EVENT_OCCURED = exports.NOTIFY_CONSOLE_EVENT_OCCURED = 'notify|event|console';\n\t\n\tvar ConsoleProxy = exports.ConsoleProxy = function () {\n\t    function ConsoleProxy() {\n\t        _classCallCheck(this, ConsoleProxy);\n\t\n\t        // NOTE: this should probably be pulled from the inspector,\n\t        //       but that raising a dependency question and whether\n\t        //       one should know about the other. Was thinking about\n\t        //       adding a neutral party but thats overkill.\n\t        this.methods = ['assert', 'count', 'debug', 'dir', 'dirxml', 'error', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];\n\t    }\n\t\n\t    _createClass(ConsoleProxy, [{\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            // IE9 and older throws an exception if we try and write a value to\n\t            // an undefined preoprty on console methods, so we test here if we\n\t            // can write to `console.log`, and if not return not supported\n\t            try {\n\t                // tslint:disable-next-line:no-any\n\t                console.log.__glimpse_enabled = true;\n\t                // tslint:disable-next-line:no-any\n\t                delete console.log.__glimpse_enabled;\n\t            } catch (e) {\n\t                return false;\n\t            }\n\t            return !!(window && typeof window.console !== 'undefined');\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            this.methods.forEach(function (methodKey) {\n\t                if (methodKey && console[methodKey] && !console[methodKey].__glimpse_original) {\n\t                    console[methodKey] = function (key) {\n\t                        var oldFunction = console[key];\n\t                        var newFunction = function newFunction() {\n\t                            var args = Array.prototype.slice.call(arguments);\n\t                            _Tracing2['default'].publish(NOTIFY_CONSOLE_EVENT_OCCURED, { method: key, arguments: args });\n\t                            return oldFunction.apply(this, arguments);\n\t                        };\n\t                        oldFunction.__glimpse_proxy = newFunction;\n\t                        newFunction.__glimpse_original = oldFunction;\n\t                        return newFunction;\n\t                    }(methodKey);\n\t                }\n\t            });\n\t        }\n\t    }]);\n\n\t    return ConsoleProxy;\n\t}();\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.PerformanceInspector = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _PerformanceProxy = __webpack_require__(31);\n\t\n\tvar _MessageMixins = __webpack_require__(6);\n\t\n\tvar _CallStackUtilities = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar PerformanceInspector = exports.PerformanceInspector = function () {\n\t    function PerformanceInspector() {\n\t        _classCallCheck(this, PerformanceInspector);\n\t\n\t        this.markIdCache = {};\n\t    }\n\t\n\t    _createClass(PerformanceInspector, [{\n\t        key: 'init',\n\t        value: function init(messagePublisher) {\n\t            var _this = this;\n\t\n\t            this.messagePublisher = messagePublisher;\n\t            _Tracing2['default'].on(_PerformanceProxy.EVENT_PERFORMANCE_MARK, function (data) {\n\t                return _this.mark(data);\n\t            });\n\t            _Tracing2['default'].on(_PerformanceProxy.EVENT_PERFORMANCE_MEASURE, function (data) {\n\t                return _this.measure(data);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'mark',\n\t        value: function mark(data) {\n\t            var _this2 = this;\n\t\n\t            var eventData = data.data;\n\t            var message = this.messagePublisher.createMessage('debug-timestamp', {\n\t                name: eventData.name\n\t            });\n\t            // Save the internal ID <> message ID correlation for lookup in measure\n\t            // events. We do this two stage caching level so that proxies don't need\n\t            // to know anything about the details of how message IDs work.\n\t            this.markIdCache[eventData.id] = message.id;\n\t            // Override the message offset directly. We override it manually instead\n\t            // of using `addOffset` because that method adjust the offset we pass to\n\t            // be relative to `performance.timing.requestStart - performance.timing.fetchStart`\n\t            // however the offsets we receive here are from performance.timing, so they\n\t            // are already relative to the proper time, and so shouldn't be adjusted\n\t            message.offset = eventData.startTime;\n\t            // If the mark is a built-in mark, then we skip collecting the stack trace\n\t            // because there is no actual stack trace associated with the mark\n\t            if (eventData.isBuiltIn) {\n\t                // Wrap the publish in a set timeout to make the asynchronicity\n\t                // of this method consistent across different event configurations\n\t                setTimeout(function () {\n\t                    return _this2.messagePublisher.publishMessage(message);\n\t                }, 0);\n\t            } else {\n\t                // We create the message first, and add frames later, to ensure that\n\t                // the mark ID cache is filled and waiting when `performance.measure`\n\t                // is called, which may occur before the getStackTrace callback is\n\t                // called.\n\t                (0, _CallStackUtilities.getStackTrace)(function (frames) {\n\t                    message.payload.frames = frames;\n\t                    _this2.messagePublisher.publishMessage(message);\n\t                });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'measure',\n\t        value: function measure(data) {\n\t            var eventData = data.data;\n\t            var startMarkMessageId = this.markIdCache[eventData.startMarkId];\n\t            var endMarkMessageId = this.markIdCache[eventData.endMarkId];\n\t            var message = this.messagePublisher.createMessage('debug-timestamp-measurement', {\n\t                correlationMessageIds: [startMarkMessageId, endMarkMessageId],\n\t                category: 'duration',\n\t                name: eventData.name\n\t            });\n\t            (0, _MessageMixins.addOffset)(data.offset, message);\n\t            this.messagePublisher.publishMessage(message);\n\t        }\n\t    }]);\n\n\t    return PerformanceInspector;\n\t}();\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.PerformanceProxy = exports.EVENT_PERFORMANCE_MEASURE = exports.EVENT_PERFORMANCE_MARK = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _Tracing = __webpack_require__(10);\n\t\n\tvar _Tracing2 = _interopRequireDefault(_Tracing);\n\t\n\tvar _PerformanceUtilities = __webpack_require__(25);\n\t\n\tvar _PerformanceUtilities2 = _interopRequireDefault(_PerformanceUtilities);\n\t\n\tvar _GeneralUtilities = __webpack_require__(4);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar EVENT_PERFORMANCE_MARK = exports.EVENT_PERFORMANCE_MARK = 'invoke|post|performance.mark';\n\tvar EVENT_PERFORMANCE_MEASURE = exports.EVENT_PERFORMANCE_MEASURE = 'invoke|post|performance.measure';\n\tvar measureIdCount = 1;\n\t\n\tvar PerformanceProxy = exports.PerformanceProxy = function () {\n\t    function PerformanceProxy() {\n\t        _classCallCheck(this, PerformanceProxy);\n\t\n\t        this.markIdCache = {};\n\t    }\n\t\n\t    _createClass(PerformanceProxy, [{\n\t        key: 'getMarkId',\n\t        value: function getMarkId(name) {\n\t            // Check if we have a cached mark entry, and if so, return it\n\t            if (this.markIdCache[name]) {\n\t                return this.markIdCache[name];\n\t            }\n\t            // If we got here, then that means there is not a cached mark entry,\n\t            // meaning we haven't seen the mark before. This can happen for two reasons:\n\t            // 1) The name is not a known mark name. Technically it shouldn't ever\n\t            //    get to this method, because `performance.measure` will throw first\n\t            // 2) The name is a built-in performance timing mark that the browser\n\t            //    generated on page load. These are stored in `performance.timing`\n\t            // This checks if we have a built-in `performance.timing` mark. If\n\t            // we do have a built in `performance.timing` mark, we create a mark\n\t            // message for this retroactively and publish a mark event. Note:\n\t            // if this built in mark was already referenced, it will be in the\n\t            // cache, meaning that this code will not be run twice for the same mark\n\t            if (_PerformanceUtilities2['default'].timing[name]) {\n\t                // We do a little hack here to get the `startTime` of the entry\n\t                // by measuring this mark against itself and getting the\n\t                // resulting performance entry\n\t                var tempMeasureName = '__glimpse_measure-' + measureIdCount++;\n\t                this.oldMeasure.call(_PerformanceUtilities2['default'], tempMeasureName, name, name);\n\t                var tempMeasureEntry = this.getPerformanceEntryByName(tempMeasureName);\n\t                var eventData = this.initializeMark(name, tempMeasureEntry.startTime, true);\n\t                // We clear the measure entry now so we can keep the `performance.getEntries`\n\t                // history clean for users who want to query performance entries\n\t                _PerformanceUtilities2['default'].clearMeasures(tempMeasureName);\n\t                _Tracing2['default'].publish(EVENT_PERFORMANCE_MARK, eventData);\n\t                return eventData.id;\n\t            }\n\t            // If we got here, then it means the mark name is not valid. We _shouldn't_\n\t            // ever get here, because the browser's native `performance.measure` method\n\t            // will throw if the name is not know before this method is called.\n\t            return undefined;\n\t        }\n\t    }, {\n\t        key: 'getPerformanceEntryByName',\n\t        value: function getPerformanceEntryByName(name) {\n\t            return _PerformanceUtilities2['default'].getEntriesByName(name).pop();\n\t        }\n\t    }, {\n\t        key: 'initializeMark',\n\t        value: function initializeMark(name, startTime, isBuiltIn) {\n\t            var id = (0, _GeneralUtilities.getGuid)();\n\t            var eventData = {\n\t                id: id,\n\t                name: name,\n\t                startTime: startTime,\n\t                isBuiltIn: isBuiltIn\n\t            };\n\t            // We only need to store the newest ID in the cache because `performance.measure`\n\t            // always grabs the newest mark with a given name. For more info, see\n\t            // https://www.w3.org/TR/user-timing/#dom-performance-measure\n\t            this.markIdCache[name] = id;\n\t            return eventData;\n\t        }\n\t    }, {\n\t        key: 'instrumentMark',\n\t        value: function instrumentMark() {\n\t            var oldMark = _PerformanceUtilities2['default'].mark;\n\t            var self = this;\n\t            _PerformanceUtilities2['default'].mark = function mark(name) {\n\t                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                    args[_key - 1] = arguments[_key];\n\t                }\n\t\n\t                oldMark.call.apply(oldMark, [this, name].concat(args));\n\t                var performanceEntry = self.getPerformanceEntryByName(name);\n\t                var eventData = self.initializeMark(performanceEntry.name, performanceEntry.startTime, false);\n\t                _Tracing2['default'].publish(EVENT_PERFORMANCE_MARK, eventData);\n\t            };\n\t        }\n\t    }, {\n\t        key: 'instrumentMeasure',\n\t        value: function instrumentMeasure() {\n\t            this.oldMeasure = _PerformanceUtilities2['default'].measure;\n\t            var self = this;\n\t            _PerformanceUtilities2['default'].measure = function measure(name, startMark, endMark) {\n\t                var _self$oldMeasure;\n\t\n\t                for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t                    args[_key2 - 3] = arguments[_key2];\n\t                }\n\t\n\t                (_self$oldMeasure = self.oldMeasure).call.apply(_self$oldMeasure, [this, name, startMark, endMark].concat(args));\n\t                var startMarkId = self.getMarkId(startMark);\n\t                var endMarkId = self.getMarkId(endMark);\n\t                if (startMarkId && endMarkId) {\n\t                    var eventData = {\n\t                        name: name,\n\t                        startMarkId: startMarkId,\n\t                        endMarkId: endMarkId\n\t                    };\n\t                    _Tracing2['default'].publish(EVENT_PERFORMANCE_MEASURE, eventData);\n\t                }\n\t            };\n\t        }\n\t    }, {\n\t        key: 'isSupported',\n\t        value: function isSupported() {\n\t            return !!(_PerformanceUtilities2['default'] && _PerformanceUtilities2['default'].getEntriesByName);\n\t        }\n\t    }, {\n\t        key: 'init',\n\t        value: function init() {\n\t            if (_PerformanceUtilities2['default'].mark) {\n\t                this.instrumentMark();\n\t            }\n\t            if (_PerformanceUtilities2['default'].measure) {\n\t                this.instrumentMeasure();\n\t            }\n\t        }\n\t    }]);\n\n\t    return PerformanceProxy;\n\t}();\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports['default'] = initializeProxies;\n\t\n\tvar _XHRProxy = __webpack_require__(9);\n\t\n\tvar _FetchProxy = __webpack_require__(22);\n\t\n\tvar _ResourceTimingProxy = __webpack_require__(24);\n\t\n\tvar _NavigationTimingProxy = __webpack_require__(27);\n\t\n\tvar _ConsoleProxy = __webpack_require__(29);\n\t\n\tvar _PerformanceProxy = __webpack_require__(31);\n\t\n\tvar proxies = {\n\t    XHRProxy: _XHRProxy.XHRProxy,\n\t    FetchProxy: _FetchProxy.FetchProxy,\n\t    ResourceTimingProxy: _ResourceTimingProxy.ResourceTimingProxy,\n\t    NavigationTimingProxy: _NavigationTimingProxy.NavigationTimingProxy,\n\t    ConsoleProxy: _ConsoleProxy.ConsoleProxy,\n\t    PerformanceProxy: _PerformanceProxy.PerformanceProxy\n\t};\n\tfunction initializeProxies() {\n\t    for (var proxyName in proxies) {\n\t        if (proxies.hasOwnProperty(proxyName)) {\n\t            var proxy = new proxies[proxyName]();\n\t            // Only initiate (attach) proxies if they are\n\t            // able to be used in the client.\n\t            if (proxy.isSupported()) {\n\t                proxy.init();\n\t            }\n\t        }\n\t    }\n\t}\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// agent.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap af053e5c570ff6d37255","if (window.Symbol) {\n    require('./Agent');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Bootstrap.js","import { MessagePublisher } from './MessagePublisher';\n\nimport { XHRInspector } from './inspectors/XHRInspector';\nimport { FetchInspector } from './inspectors/FetchInspector';\nimport { ResourceTimingInspector } from './inspectors/ResourceTimingInspector';\nimport { NavigationTimingInspector } from './inspectors/NavigationTimingInspector';\nimport { ConsoleInspector } from './inspectors/ConsoleInspector';\nimport { PerformanceInspector } from './inspectors/PerformanceInspector';\n\nimport initializeProxies from './tracing/initializeProxies';\n\nconst messagePublisher = new MessagePublisher();\n\n// We initialize the inspectors before the proxies so that they are wired up and\n// ready to receive events from proxies in case a proxy wants to emit an event\n// in its `init` method (the Resource Timing proxy does this).\nnew XHRInspector().init(messagePublisher);\nnew FetchInspector().init(messagePublisher);\nnew ResourceTimingInspector().init(messagePublisher);\nnew NavigationTimingInspector().init(messagePublisher);\nnew ConsoleInspector().init(messagePublisher);\nnew PerformanceInspector().init(messagePublisher);\n\ninitializeProxies();\n\n\n\n// WEBPACK FOOTER //\n// ./src/Agent.ts","import { ajax } from 'nanoajax';\nimport { getGuid } from './common/GeneralUtilities';\nimport { getRequestId, getMessageIngressUrl, getConfigSettingNumber } from './common/RequestUtilities';\nimport { addOffset } from './common/MessageMixins';\n\nexport interface IMessage {\n    context: {\n        id: string,\n        type: string\n    };\n    id: string;\n    ordinal: number;\n    payload;\n    types: string[];\n    agent: {\n        source: 'browser';\n    };\n    offset: number;\n}\n\ninterface IRange {\n    start: number;\n    end: number;\n}\n\n/**\n * break a list of messages into group so that the groups are under maxSize.\n * If any individual message is over maxSize, it will be grouped on its own.\n * returns an of IRange instances, where start is inclusive & end is exclusive.\n *\n * Exported for test purposes.\n */\nexport function chunkMessages(messageBodies: string[], maxSize: number): IRange[] {\n    const ranges: IRange[] = [];\n    let sum = 0;\n    let lastStart = 0;\n\n    for (let i = 0; i < messageBodies.length; i++) {\n        sum += messageBodies[i].length;\n        if (messageBodies[i].length > maxSize) {\n            if (lastStart !== i) {\n                // when a single message is over the limit, we want to send previous messages in their own batch\n                ranges.push({ start: lastStart, end: i });\n            }\n            ranges.push({ start: i, end: i + 1 });\n            lastStart = i + 1;\n            sum = 0;\n        }\n        else if (sum > maxSize) {\n            ranges.push({ start: lastStart, end: i });\n            lastStart = i;\n            sum = messageBodies[i].length;\n        }\n    }\n\n    if (lastStart < messageBodies.length) {\n        ranges.push({ start: lastStart, end: messageBodies.length });\n    }\n\n    return ranges;\n}\n\n/**\n * given an array of serialized message bodies & array of ranges,\n * break them into JSON-serialized sub-arrays as defined by the ranges.\n *\n * Exported for test purposes.\n */\nexport function serializeRanges(messageBodies: string[], ranges: IRange[]): string[] {\n    const payloads: string[] = [];\n\n    for (let i = 0; i < ranges.length; i++) {\n        if (ranges[i].end > ranges[i].start) {\n            const subBodies = messageBodies.slice(ranges[i].start, ranges[i].end);\n            const payload = '[' + subBodies.join(',') + ']';\n            payloads.push(payload);\n        }\n    }\n    return payloads;\n}\n\nexport interface IMessagePublisher {\n    createMessage(type: string | string[], payload): IMessage;\n\n    publishMessage(message: IMessage): void;\n\n    createAndPublishMessage(type: string, payload): void;\n}\n\nexport class MessagePublisher implements IMessagePublisher {\n    private static timeout = 250;\n    private ordinal = 1;\n    private messageQueue: IMessage[] = [];\n    private messageTimeout = undefined;\n\n    public createMessage(type: string | string[], payload): IMessage {\n        const types = Array.isArray(type) ? type : [type];\n        const msg: IMessage = {\n            id: getGuid(),\n            types,\n            payload,\n            context: {\n                id: getRequestId(),\n                type: 'Request'\n            },\n            ordinal: this.ordinal++,\n            agent: {\n                source: 'browser'\n            },\n            offset: 0\n        };\n\n        addOffset(performance.now(), msg);\n        return msg;\n\n    }\n\n    public publishMessage(message: IMessage): void {\n        // finish getting message ready for sending\n        message.payload = JSON.stringify(message); // tslint:disable-line:no-string-literal\n\n        // add messages to queu\n        this.messageQueue.push(message);\n\n        // only setup the timeout if we need to\n        if (!this.messageTimeout) {\n            this.messageTimeout = setTimeout(() => {\n                this.messageTimeout = undefined;\n                this.sendData();\n            }, MessagePublisher.timeout);\n        }\n    };\n\n    public createAndPublishMessage(type: string, payload): void {\n        this.publishMessage(this.createMessage(type, payload));\n    };\n\n    private sendPayload(body) {\n        // send data with all the data that we have batched up\n        ajax({\n            url: getMessageIngressUrl(),\n            method: 'POST',\n            body: body\n        }, () => {\n            // not doing anything atm\n        });\n    }\n\n    private sendData() {\n        // we'll chunk the pooled messages into individual requests to try stay under\n        // some size limit for http payloads.\n\n        const maxBodySize = getConfigSettingNumber('server.max.json.body.size', 100000);\n        const bodies: string[] = [];\n\n        this.messageQueue.forEach((m) => {\n            bodies.push(JSON.stringify(m));\n        });\n\n        const ranges = chunkMessages(bodies, maxBodySize);\n        const payloads = serializeRanges(bodies, ranges);\n\n        payloads.forEach((payload) => {\n            this.sendPayload(payload);\n        });\n\n        this.messageQueue = [];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MessagePublisher.ts","// Best place to find information on XHR features is:\n// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\nvar reqfields = [\n  'responseType', 'withCredentials', 'timeout', 'onprogress'\n]\n\n// Simple and small ajax function\n// Takes a parameters object and a callback function\n// Parameters:\n//  - url: string, required\n//  - headers: object of `{header_name: header_value, ...}`\n//  - body:\n//      + string (sets content type to 'application/x-www-form-urlencoded' if not set in headers)\n//      + FormData (doesn't set content type so that browser will set as appropriate)\n//  - method: 'GET', 'POST', etc. Defaults to 'GET' or 'POST' based on body\n//  - cors: If your using cross-origin, you will need this true for IE8-9\n//\n// The following parameters are passed onto the xhr object.\n// IMPORTANT NOTE: The caller is responsible for compatibility checking.\n//  - responseType: string, various compatability, see xhr docs for enum options\n//  - withCredentials: boolean, IE10+, CORS only\n//  - timeout: long, ms timeout, IE8+\n//  - onprogress: callback, IE10+\n//\n// Callback function prototype:\n//  - statusCode from request\n//  - response\n//    + if responseType set and supported by browser, this is an object of some type (see docs)\n//    + otherwise if request completed, this is the string text of the response\n//    + if request is aborted, this is \"Abort\"\n//    + if request times out, this is \"Timeout\"\n//    + if request errors before completing (probably a CORS issue), this is \"Error\"\n//  - request object\n//\n// Returns the request object. So you can call .abort() or other methods\n//\n// DEPRECATIONS:\n//  - Passing a string instead of the params object has been removed!\n//\nexports.ajax = function (params, callback) {\n  // Any variable used more than once is var'd here because\n  // minification will munge the variables whereas it can't munge\n  // the object access.\n  var headers = params.headers || {}\n    , body = params.body\n    , method = params.method || (body ? 'POST' : 'GET')\n    , called = false\n\n  var req = getRequest(params.cors)\n\n  function cb(statusCode, responseText) {\n    return function () {\n      if (!called) {\n        callback(req.status === undefined ? statusCode : req.status,\n                 req.status === 0 ? \"Error\" : (req.response || req.responseText || responseText),\n                 req)\n        called = true\n      }\n    }\n  }\n\n  req.open(method, params.url, true)\n\n  var success = req.onload = cb(200)\n  req.onreadystatechange = function () {\n    if (req.readyState === 4) success()\n  }\n  req.onerror = cb(null, 'Error')\n  req.ontimeout = cb(null, 'Timeout')\n  req.onabort = cb(null, 'Abort')\n\n  if (body) {\n    setDefault(headers, 'X-Requested-With', 'XMLHttpRequest')\n\n    if (!global.FormData || !(body instanceof global.FormData)) {\n      setDefault(headers, 'Content-Type', 'application/x-www-form-urlencoded')\n    }\n  }\n\n  for (var i = 0, len = reqfields.length, field; i < len; i++) {\n    field = reqfields[i]\n    if (params[field] !== undefined)\n      req[field] = params[field]\n  }\n\n  for (var field in headers)\n    req.setRequestHeader(field, headers[field])\n\n  req.send(body)\n\n  return req\n}\n\nfunction getRequest(cors) {\n  // XDomainRequest is only way to do CORS in IE 8 and 9\n  // But XDomainRequest isn't standards-compatible\n  // Notably, it doesn't allow cookies to be sent or set by servers\n  // IE 10+ is standards-compatible in its XMLHttpRequest\n  // but IE 10 can still have an XDomainRequest object, so we don't want to use it\n  if (cors && global.XDomainRequest && !/MSIE 1/.test(navigator.userAgent))\n    return new XDomainRequest\n  if (global.XMLHttpRequest)\n    return new XMLHttpRequest\n}\n\nfunction setDefault(obj, key, value) {\n  obj[key] = obj[key] || value\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/nanoajax/index.js\n// module id = 3\n// module chunks = 0","export function getGuid(): string {\n    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        /* tslint:disable:no-bitwise */\n        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        /* tslint:enable:no-bitwise */\n        return v.toString(16);\n    });\n}\n\nexport function convertBlobToText(blob: Blob, encoding: string, cb: (content: string) => void) {\n    const fileReader = new FileReader();\n    fileReader.onloadend = () => {\n        cb(fileReader.result);\n    };\n    fileReader.readAsText(blob, encoding);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/GeneralUtilities.ts","import { getGuid } from './GeneralUtilities';\n\nexport function getRequestId(): string {\n    // NOTE: agent should look to see if it can get the id\n    //       from a script tag first, then if it can't find\n    //       it there look to for a cookie (in the case where\n    //       we can't inject a script tag) and finally it will\n    //       create one which will be used moving forward\n    //       (CDN scenario).\n    let id = document.getElementById('__glimpse_browser_agent').getAttribute('data-request-id');\n    if (!id) {\n        id = getCookie('.Glimpse.RequestId');\n    }\n    if (!id) {\n        id = getGuid();\n    }\n    return id;\n}\n\nexport function getConfigSettingNumber(key: string, defaultValue: number, settings?: Object): number {\n    let value = defaultValue;\n    if (!settings) {\n        settings = getConfigSettings();\n    }\n    if (settings && settings.hasOwnProperty(key)) {\n        const v = settings[key];\n        if (typeof v === 'string') {\n            const num = parseInt(v, 10);\n            if (!Number.isNaN(num)) {\n                value = num;\n            }\n        } else if (typeof v === 'number') {\n            value = v;\n        }\n    }\n    return value;\n}\n\nexport function getConfigSettings(): Object {\n    let settings = {};\n    const el = document.getElementById('__glimpse_browser_agent');\n    if (el) {\n        const val = el.getAttribute('config-settings');\n        if (settings) {\n            try {\n                settings = JSON.parse(val);\n            }\n            catch (err) {\n                // tslint:disable-next-line:no-console\n                console.error('Error parsing config settings: ' + err);\n            }\n        }\n    }\n    return settings;\n}\n\nexport function addEvent(element, eventName: string, cb): void {\n    if (element.addEventListener) {\n        element.addEventListener(eventName, cb, false);\n    } else if (element.attachEvent) {\n        element.attachEvent('on' + eventName, cb);\n    }\n}\n\nexport function getCookie(cookie) {\n    // Modified from https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie\n    const regexp = new RegExp('(?:(?:^|.*;\\\\s*)' + cookie + '\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$');\n    return document.cookie.replace(regexp, '$1');\n}\n\nexport interface IHeaders {\n    [header: string]: string | number | boolean;\n}\n\nexport function getHeaderKeys(headers: Headers): string[] {\n    const headerKeys = [];\n    // tslint:disable-next-line:no-any\n    if ((<any>headers).keys) {\n        // tslint:disable-next-line:no-any\n        for (const header of (<any>headers).keys()) {\n            headerKeys.push(header);\n        }\n    } else if (headers.forEach) {\n        headers.forEach((value, name) => headerKeys.push(name));\n    }\n    return headerKeys;\n}\n\n// Headers are not technically case sensitive, and the browser often normalizes\n// header so that they are all lower case and all strings. This method does the\n// same so that headers are always normalized from the browser agent in all cases.\nexport function normalizeHeaders(headers: IHeaders): IHeaders {\n    const normalizedHeaders: IHeaders = {};\n    for (const header in headers) {\n        if (!headers.hasOwnProperty(header)) {\n            continue;\n        }\n\n        let headerVal = headers[header];\n        // tslint:disable-next-line:no-null-keyword\n        if (headerVal !== undefined && headerVal !== null && typeof headerVal !== 'string') {\n            headerVal = headerVal.toString();\n        }\n        normalizedHeaders[header.toLowerCase()] = headerVal;\n    }\n    return normalizedHeaders;\n}\n\nexport function getMessageIngressUrl(): string {\n    return document\n        .getElementById('__glimpse_browser_agent')\n        .getAttribute('data-message-ingress-template');\n}\n\nexport interface IParsedUrl {\n    protocol: string;\n    hostname: string;\n    port?: number;\n    pathname: string;\n    search: string;\n    hash: string;\n}\n\nexport function parseUrl(url: string): IParsedUrl {\n    const parser = document.createElement('a');\n    parser.href = url;\n    const parsedPort = parseInt(parser.port, 10);\n    return {\n        protocol: parser.protocol,\n        hostname: parser.hostname,\n        port: isNaN(parsedPort) ? undefined : parsedPort,\n        pathname: parser.pathname,\n        search: parser.search,\n        hash: parser.hash\n    };\n}\n\nexport function stringifyUrl(url: IParsedUrl): string {\n    const portSuffix = url.port !== undefined ? `:${url.port}` : '';\n    let stringifiedUrl = `${url.protocol}//${url.hostname}${portSuffix}${url.pathname}`;\n    if (url.search) {\n        stringifiedUrl += url.search;\n    }\n    if (url.hash) {\n        stringifiedUrl += url.hash;\n    }\n    return stringifiedUrl;\n}\n\nconst urlCache = {};\nexport function resolveUrl(url: string): string {\n    if (urlCache[url]) {\n        return urlCache[url];\n    }\n    return (urlCache[url] = stringifyUrl(parseUrl(url)));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/RequestUtilities.ts","\nexport function addOffset(offset: number, envelope) {\n    envelope.offset = offset;\n}\n\nexport function addCorrelationBegin(correlationId, envelope) {\n    envelope.types.push('correlation-begin');\n\n    addCorrelation(correlationId, envelope);\n}\n\nexport function addCorrelationEnd(correlationId, duration, envelope) {\n    envelope.types.push('correlation-end');\n    envelope.payload.duration = duration;\n\n    addCorrelation(correlationId, envelope);\n}\n\nexport function addCorrelation(correlationId, envelope) {\n    envelope.types.push('correlation');\n    envelope.payload.correlationId = correlationId;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/MessageMixins.ts","import logger from '../common/GlimpseLogger';\nimport { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { addOffset } from '../common/MessageMixins';\nimport {\n    IRequestSentEvent, EVENT_XHR_REQUEST_SENT,\n    IResponseReceivedEvent, EVENT_XHR_RESPONSE_RECEIVED,\n    EVENT_XHR_ERROR,\n    EVENT_XHR_ABORT\n} from '../tracing/proxies/XHRProxy';\nimport tracing from '../tracing/Tracing';\nimport { getDateTime } from '../common/DateTimeUtilities';\nimport { parseUrl, normalizeHeaders, IHeaders } from '../common/RequestUtilities';\nimport parse from 'parse-headers';\nimport {\n    tryFindResourceTimingObject,\n    getMultiPartFormBoundary,\n    getMultiPartFormParts,\n    IBody,\n    IPartSummary,\n    createBodyForBlob,\n    createEmptyBody,\n    getMaxHTTPBodySize\n} from './HttpRequestUtils';\nimport { getStackTrace } from '../common/CallStackUtilities';\n\ninterface IRequestCacheEntry {\n    startTimeStamp: number;\n    startTimeOffset: number;\n}\n\nexport class XHRInspector implements IInspector {\n\n    private initiatorRegExp = /xmlhttprequest/i;\n\n    private messagePublisher: IMessagePublisher;\n\n    private requests: { [id: string]: IRequestCacheEntry } = {};\n\n    private createBodyProperty(headers: IHeaders, body: string | ArrayBuffer | ArrayBufferView | Blob | Document | FormData, cb: (bodyProperty: IBody) => void) {\n        //\n        // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n        // irrespective of whether createBodyForBlob is called.  For a more in-depth discussion,\n        // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n        //\n        if (!body) {\n            const bodyProperty = createEmptyBody(false);\n            setTimeout(() => cb(bodyProperty), 0);\n        }\n        else {\n            //\n            // according to MDN docs, body here can be one of the following types:\n            // ArrayBufferView | Blob | Document | string | FormData.  We need to\n            // account for all of these.\n            //\n            if (typeof body === 'string') {\n                const contentType = headers['content-type'] as string;\n                const boundary = getMultiPartFormBoundary(contentType);\n                const bodyProperty: IBody = {\n                    size: body.length,\n                    encoding: 'utf8',\n                    isTruncated: body.length > getMaxHTTPBodySize(),\n                    parts: getMultiPartFormParts(boundary, body),\n                    content: body.slice(0, getMaxHTTPBodySize())\n                };\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (body instanceof Blob) {\n                const contentType = headers['content-type'] as string;\n                const blob = body as Blob;\n                createBodyForBlob(contentType, blob, true, (bodyProperty: IBody) => {\n                    cb(bodyProperty);\n                });\n            }\n            else if (body instanceof ArrayBuffer || ((body as ArrayBufferView).buffer && (body as ArrayBufferView).buffer instanceof ArrayBuffer)) {\n                let buffer: ArrayBuffer;\n                if (body instanceof ArrayBuffer) {\n                    buffer = body;\n                }\n                else {\n                    buffer = (body as ArrayBufferView).buffer;\n                }\n\n                // TODO:  support body capture when body is ArrayBuffer\n                const bodyProperty: IBody = {\n                    size: buffer.byteLength,\n                    encoding: 'none',\n                    isTruncated: true,\n                    parts: [],\n                    content: ''\n                };\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (body instanceof Document) {\n                // TODO:  support body capture when body is Document\n                const doc = body as Document;\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (body instanceof FormData) {\n                // TODO:  support body capture when body is FormData\n                const fd = body as FormData;\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else if (typeof body === 'object') {\n                // TODO:  support body capture when body is object\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n            else {\n                const bodyProperty = createEmptyBody(true);\n                setTimeout(() => cb(bodyProperty), 0);\n            }\n        }\n    }\n\n    private before(event: IProxyEvent) {\n        const eventData: IRequestSentEvent = event.data;\n        const url = parseUrl(eventData.url);\n        const headers = normalizeHeaders(eventData.headers);\n        getStackTrace((frames) => {\n            this.createBodyProperty(headers, eventData.body, (body: IBody) => {\n                const startTime = getDateTime(new Date(event.timeStamp));\n                const msg = this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n                    correlationId: eventData.id,\n                    protocol: {\n                        identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n                    },\n                    url: eventData.url,\n                    method: eventData.method,\n                    startTime,\n                    timing: {\n                        startTime: 0\n                    },\n                    headers,\n                    isAjax: true,\n                    body,\n                    frames: frames.slice(0, 1)\n                });\n                addOffset(event.offset, msg);\n                this.messagePublisher.publishMessage(msg);\n            });\n        });\n    }\n\n    private after(event: IProxyEvent, requestEntry: IRequestCacheEntry) {\n        const eventData: IResponseReceivedEvent = event.data;\n        tryFindResourceTimingObject(event.data.id, this.initiatorRegExp, eventData.url, requestEntry.startTimeOffset, (timings: PerformanceResourceTiming) => {\n\n            const offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n            // start here is relative to this http client request, so it is always 0\n            const startTime = 0;\n            // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n            const responseStart = timings && (timings.responseStart >= timings.startTime) ? (timings.responseStart - timings.startTime) : undefined;\n            const responseEnd = timings ? (timings.responseEnd - timings.startTime) : (event.offset - requestEntry.startTimeOffset);\n\n            const headers = parse(eventData.xhr.getAllResponseHeaders());\n            // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n            // Add support for base64 encoding non-text content by setting the encoding here\n            this.createBodyProperty(headers, eventData.body, (body) => {\n                const msg = this.messagePublisher.createMessage('data-http-response', {\n                    correlationId: eventData.id,\n                    url: eventData.url,\n                    headers,\n                    statusCode: eventData.statusCode,\n                    statusMessage: eventData.statusMessage,\n                    endTime: getDateTime(new Date(event.timeStamp)),\n                    duration: responseEnd,\n                    timing: {\n                        startTime: 0,\n                        responseEnd\n                    },\n                    body\n                });\n\n                if (responseStart !== undefined) {\n                    msg.payload.timing.responseStart = responseStart;\n                }\n\n                addOffset(offset, msg);\n                this.messagePublisher.publishMessage(msg);\n            });\n        });\n    }\n\n    public numOutstandingRequests() {\n        return Object.keys(this.requests).length;\n    }\n\n    public init(messagePublisher: IMessagePublisher) {\n        this.messagePublisher = messagePublisher;\n\n        tracing.on(EVENT_XHR_REQUEST_SENT, (event: IProxyEvent) => {\n            this.requests[event.data.id] = {\n                startTimeStamp: event.timeStamp,\n                startTimeOffset: event.offset\n            };\n            this.before(event);\n        });\n\n        tracing.on(EVENT_XHR_RESPONSE_RECEIVED, (event: IProxyEvent) => {\n            const requestEntry = this.requests[event.data.id];\n            if (!requestEntry) {\n                logger.error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n                return;\n            }\n            this.after(event, requestEntry);\n            delete this.requests[event.data.id];\n        });\n\n        tracing.on(EVENT_XHR_ERROR, (data: IProxyEvent) => {\n            delete this.requests[data.data.id];\n        });\n\n        tracing.on(EVENT_XHR_ABORT, (data: IProxyEvent) => {\n            delete this.requests[data.data.id];\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/XHRInspector.ts","export interface IGlimpseLogger {\n    error(message?: string): void;\n}\n\nexport class GlimpseLogger implements IGlimpseLogger {\n    constructor(private logToConsole: boolean) {\n    }\n\n    public error(message?: string): void {\n        if (this.logToConsole) {\n            // tslint:disable-next-line:no-console\n            console.error(message);\n        }\n    }\n}\n\nconst logger = new GlimpseLogger(LOG_TO_CONSOLE);\n\nexport default logger;\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/GlimpseLogger.ts","import logger from '../../common/GlimpseLogger';\nimport { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getGuid } from '../../common/GeneralUtilities';\nimport { getMessageIngressUrl, resolveUrl } from '../../common/RequestUtilities';\n\nexport type EventBody = ArrayBuffer | ArrayBufferView | Blob | Document | string | FormData;\n\n/**\n * This event indicates that a request was sent, as indicated by a call to\n * an XMLHttpRequest instance's `send()` method.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {string} url - The resolved URL for the request\n * @property {string} method - The request method, e.g. \"GET\"\n * @property {object} headers - The request headers, represented as a key-value dictionary\n * @property {string} body - The body of the request, as passed to `xhr.send(body)`\n */\nexport interface IRequestSentEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n    url: string;\n    method: string;\n    headers;\n    body: EventBody;\n}\nexport const EVENT_XHR_REQUEST_SENT = 'invoke|pre|XMLHttpRequest.request-sent';\n\n/**\n * This event indicates that a response was received. This event is fired either\n * as a response to a `readystatechange` event from the XMLHttpRequest object,\n * or that the `xhr.send()` method has returned, depending on if the request was\n * synchronous or asynchronous.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {string} url - The resolved URL for the request\n * @property {statusCode} number - The response status code, e.g. 200\n * @property {bodyType} string - The data type of the body, as reported by `xhr.responseType`\n * @property {string} body - The body of the request, as passed to `xhr.send(body)`\n */\nexport interface IResponseReceivedEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n    url: string;\n    statusCode: number;\n    statusMessage: string;\n    bodyType: string;\n    body: EventBody;\n}\nexport const EVENT_XHR_RESPONSE_RECEIVED = 'notify|XMLHttpRequest.response-received';\n\n/**\n * This event indicates an error happened during the request. Note that an error is\n * different than the server returning an error status code. In the latter case,\n * an `EVENT_RESPONSE_RECEIVED` event is dispatched. This type of error indicates\n * that a response was not received from the server.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {error} error - A description of the error, if one is available\n */\nexport interface IErrorEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n    error: string;\n}\nexport const EVENT_XHR_ERROR = 'notify|XMLHttpRequest.error';\n\n/**\n * This event indicates that the request was cancelled during the request. Note\n * that this is slightly different than an error, because the request may have\n * been able to be completed, had it been allowed to complete. This typically\n * happens when `xhr.abort()` is called, or when the page is navigated away from\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n */\nexport interface IAbortEvent {\n    id: string;\n    xhr: XMLHttpRequest;\n}\nexport const EVENT_XHR_ABORT = 'notify|XMLHttpRequest.abort';\n\n/**\n * Proxy which wraps XHR usage and its various supporting functions.\n *\n * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n */\nexport class XHRProxy implements IProxy {\n    public static isInitialized = false;\n\n    public isSupported(): boolean {\n        // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n        // reference the property this way to get around TypeScript\n        //tslint:disable-next-line:no-any\n        return !!(window && typeof (<any>window).XMLHttpRequest !== 'undefined');\n    }\n\n    public init() {\n        if (XHRProxy.isInitialized) {\n            logger.error('Glimpse Error: Cannot initialize the XHR Proxy more than once.');\n            return;\n        }\n\n        //tslint:disable-next-line:no-any\n        const oldXMLHttpRequest = (<any>window).XMLHttpRequest;\n\n        function XMLHttpRequest() {\n            const xhr = new oldXMLHttpRequest();\n            const id = getGuid();\n\n            function handleAsyncRequest(method, url) {\n\n                const requestHeaders = {};\n\n                xhr.addEventListener('readystatechange', () => {\n                    if (xhr.readyState === oldXMLHttpRequest.DONE) {\n                        const eventData: IResponseReceivedEvent = {\n                            id,\n                            xhr,\n                            url: resolveUrl(url),\n                            statusCode: xhr.status,\n                            statusMessage: xhr.statusText,\n                            bodyType: xhr.responseType,\n                            body: xhr.response\n                        };\n                        tracing.publish(EVENT_XHR_RESPONSE_RECEIVED, eventData);\n                    };\n                });\n\n                xhr.addEventListener('error', () => {\n                    const eventData: IErrorEvent = {\n                        id,\n                        xhr,\n                        error: xhr.statusText\n                    };\n                    tracing.publish(EVENT_XHR_ERROR, eventData);\n                });\n\n                xhr.addEventListener('abort', () => {\n                    const eventData: IAbortEvent = {\n                        id,\n                        xhr\n                    };\n                    tracing.publish(EVENT_XHR_ABORT, eventData);\n                });\n\n                const oldSend = xhr.send;\n                xhr.send = function send(body, ...sendArgs) {\n                    const eventData: IRequestSentEvent = {\n                        id,\n                        xhr,\n                        method,\n                        url: resolveUrl(url),\n                        body,\n                        headers: requestHeaders\n                    };\n                    tracing.publish(EVENT_XHR_REQUEST_SENT, eventData);\n                    oldSend.call(this, body, ...sendArgs);\n                };\n\n                const oldSetRequestHeader = xhr.setRequestHeader;\n                xhr.setRequestHeader = function setRequestHeader(header, value, ...setRequestHeaderArgs) {\n                    requestHeaders[header] = value;\n                    oldSetRequestHeader.call(this, header, value, ...setRequestHeaderArgs);\n                };\n            }\n\n            function handleSyncRequest(method, url) {\n                const oldSend = xhr.send;\n\n                const requestHeaders = {};\n                const oldSetRequestHeader = xhr.setRequestHeader;\n                xhr.setRequestHeader = function setRequestHeader(header, value, ...setRequestHeaderArgs) {\n                    requestHeaders[header] = value;\n                    oldSetRequestHeader.call(this, header, value, ...setRequestHeaderArgs);\n                };\n\n                xhr.send = function send(body, ...sendArgs) {\n                    const requestEventData: IRequestSentEvent = {\n                        id,\n                        xhr,\n                        method,\n                        url: resolveUrl(url),\n                        body,\n                        headers: requestHeaders\n                    };\n                    tracing.publish(EVENT_XHR_REQUEST_SENT, requestEventData);\n                    try {\n                        oldSend.call(this, body, ...sendArgs);\n                    } catch (e) {\n                        const errorEventData: IErrorEvent = {\n                            id,\n                            xhr,\n                            error: e.message\n                        };\n                        tracing.publish(EVENT_XHR_ERROR, errorEventData);\n                        throw e;\n                    }\n                    const responseEventData: IResponseReceivedEvent = {\n                        id,\n                        xhr,\n                        url: resolveUrl(url),\n                        statusCode: xhr.status,\n                        statusMessage: xhr.statusText || '',\n                        bodyType: xhr.responseType,\n                        body: xhr.response\n                    };\n                    tracing.publish(EVENT_XHR_RESPONSE_RECEIVED, responseEventData);\n                };\n            }\n\n            const oldOpen = xhr.open;\n            xhr.open = function open(method, url, async = true, ...openArgs) {\n\n                const result = oldOpen.call(this, method, url, async, ...openArgs);\n\n                // If the url equals the message ingress url, that means it's\n                // a Glimpse message and we don't want to profile it\n                if (url !== getMessageIngressUrl()) {\n                    if (async) {\n                        handleAsyncRequest(method, url);\n                    } else {\n                        handleSyncRequest(method, url);\n                    }\n                }\n\n                return result;\n            };\n\n            return xhr;\n        }\n        // Copy the states (and anything else) from the original object to our proxy\n        for (const prop in oldXMLHttpRequest) {\n            if (oldXMLHttpRequest.hasOwnProperty(prop)) {\n                XMLHttpRequest[prop] = oldXMLHttpRequest[prop];\n            }\n        }\n\n        // Note: TypeScript doesn't know about XMLHttpRequest existing on Window, so we\n        // reference the property this way to get around TypeScript, but we also have to\n        // disable tslint in the process\n        /* tslint:disable */\n        window['XMLHttpRequest'] = XMLHttpRequest;\n        /* tslint:enable */\n\n        XHRProxy.isInitialized = true;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/XHRProxy.ts","/**\n * The Tracing module provides mechanisms for registering to receive tracing\n * events from proxies.\n *\n * This module is pretty similar to a standard EventEmitter, but has a few\n * key differences. This module provides the ability to filter out which\n * events you would like to receive, based on criteria of your choosing.\n *\n * Tracing can hurt performance in some cases, and filtering is a way for\n * the profiling application to improve performance whenever the data is not\n * explicitly needed.\n *\n * @module tracing/Tracing\n */\n\nimport { IProxyEvent } from './IProxyEvent';\n\nexport interface IEventFilterCallback {\n    (): boolean;\n}\n\nexport interface IEventCallback {\n    (eventData: IProxyEvent): void;\n}\n\ninterface IListenerEntry {\n    listener: IEventCallback;\n}\n\nclass Tracing {\n\n    private listeners: { [eventName: string]: IListenerEntry[]; } = {};\n\n    /**\n     * Publishes an event, similar to the `EventEmitter.emit` method except that it\n     * does not accept more than one data argument.\n     *\n     * @param {string} event - The name of the event to fire, and should include a\n     *      descriptive namespace, e.g. `http.request:request-created`\n     * @param {object} data - The data associated with the event\n     * @returns {boolean} - Whether or not the event was published to any listeners\n     */\n    public publish(event: string, data): boolean {\n        const listeners = this.listeners[event];\n        if (!listeners || listeners.length === 0) {\n            return false;\n        }\n        let emitted = false;\n        const message: IProxyEvent = {\n            offset: performance.now(),\n            timeStamp: Date.now(),\n            data\n        };\n        for (const listener of listeners) {\n            emitted = true;\n            listener.listener(message);\n        }\n        return emitted;\n    }\n\n    /**\n     * Register to always receive an event without any filtering. This module is\n     * returned from this method, making it possible to chain `removeEventListener`\n     * calls.\n     *\n     * Note: if any other listeners are filtering this event, registering with\n     * this method will prevent the proxies from enabling any performance\n     * optimizations.\n     *\n     * Calling this method is equivalent to calling `onFiltered(event, listener, () => true)`\n     *\n     * @param {string} event - The name of the event to listen to, e.g.\n     *      `http.request:request-created`\n     * @param {function} listener - The callback to call when the event is emitted\n     */\n    public on(event: string, listener: IEventCallback): Tracing {\n        if (!this.listeners[event]) {\n            this.listeners[event] = [];\n        }\n        this.listeners[event].push({\n            listener\n        });\n        return this;\n    }\n\n    /**\n     * Removes exactly one registered event listener. If the same callback is\n     * registered more than once, only the first copy is removed. This behavior\n     * mimics that of EventEmitter.removeEventListener\n     *\n     * @param {string} event - The name of the event to remove the listener for,\n     *      e.g. `http.request:request-created`\n     * @param {function} listener - The listener to remove\n     * @returns {object} A refernce to this module, making it possible to chain\n     *      removeEventListener calls\n     */\n    public removeEventListener(event: string, listener: IEventCallback): Tracing {\n        const listeners = this.listeners[event];\n        if (!listeners) {\n            // Matches Node.js removeEventListener return signature\n            return this;\n        }\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i].listener === listener) {\n                this.listeners[event].splice(i, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Removes all listeners for the given event. If no event is specified, then\n     * all event listeners for all events are removed.\n     *\n     * @param {string} event - (Optional) The event to remove listeners for\n     * @returns {object} A refernce to this module, making it possible to chain calls\n     */\n    public removeAllListeners(event?: string): Tracing {\n        if (event) {\n            if (this.listeners[event]) {\n                this.listeners[event] = [];\n            }\n        } else {\n            this.listeners = {};\n        }\n        return this;\n    }\n\n    /**\n     * Returns the number of listeners for the given event. This behavior\n     * mimics that of EventEmitter.listenerCount\n     *\n     * @param {string} event - The event to count listeners for\n     * @returns {number} The number of listeners for the given event\n     */\n    public listenerCount(event: string): number {\n        if (!this.listeners[event]) {\n            return 0;\n        }\n        return this.listeners[event].length;\n    }\n}\n\nexport default new Tracing();\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/Tracing.ts","function toTwoDigits(value) {\n    return value < 10 ? '0' + value : value;\n}\n\nfunction toThreeDigits(value) {\n    if (value < 10) {\n        return '00' + value;\n    }\n\n    if (value < 100) {\n        return '0' + value;\n    }\n\n    return value;\n}\n\nfunction getUTCOffset(date) {\n    let offset = date.getTimezoneOffset();\n    const sign = (offset >= 0) ? '+' : '-';\n    offset = Math.abs(offset);\n    const hours = toTwoDigits(Math.floor(offset / 60));\n    const minutes = toTwoDigits(offset % 60);\n    return sign + hours + minutes;\n}\n\n// Convert time according to the format string: 'YYYY-MM-DDTHH:mm:ss.SSS ZZ'\n// Output should look like: \"2016-06-08T09:07:11.021 -0700\"\nexport function getDateTime(d: Date = new Date()): string {\n    return d.getFullYear() + '-' + toTwoDigits(d.getMonth() + 1) + '-' + toTwoDigits(d.getDate()) + 'T' +\n        toTwoDigits(d.getHours()) + ':' + toTwoDigits(d.getMinutes()) + ':' + toTwoDigits(d.getSeconds()) + '.' +\n        toThreeDigits(d.getMilliseconds()) + getUTCOffset(d);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/DateTimeUtilities.ts","var trim = require('trim')\n  , forEach = require('for-each')\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/parse-headers/parse-headers.js\n// module id = 12\n// module chunks = 0","\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/trim/index.js\n// module id = 13\n// module chunks = 0","var isFunction = require('is-function')\n\nmodule.exports = forEach\n\nvar toString = Object.prototype.toString\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction forEach(list, iterator, context) {\n    if (!isFunction(iterator)) {\n        throw new TypeError('iterator must be a function')\n    }\n\n    if (arguments.length < 3) {\n        context = this\n    }\n    \n    if (toString.call(list) === '[object Array]')\n        forEachArray(list, iterator, context)\n    else if (typeof list === 'string')\n        forEachString(list, iterator, context)\n    else\n        forEachObject(list, iterator, context)\n}\n\nfunction forEachArray(array, iterator, context) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            iterator.call(context, array[i], i, array)\n        }\n    }\n}\n\nfunction forEachString(string, iterator, context) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        iterator.call(context, string.charAt(i), i, string)\n    }\n}\n\nfunction forEachObject(object, iterator, context) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            iterator.call(context, object[k], k, object)\n        }\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/for-each/index.js\n// module id = 14\n// module chunks = 0","module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-function/index.js\n// module id = 15\n// module chunks = 0","\nimport { convertBlobToText } from '../common/GeneralUtilities';\nimport { MAX_HTTP_BODY_SIZE } from '../common/Constants';\nimport { getConfigSettingNumber } from '../common/RequestUtilities';\n\n/**\n * interface definition for a body part of data-http-request/data-http-response message\n */\nexport interface IBody {\n    size: number;\n    encoding: string;\n    content: string;\n    isTruncated: boolean;\n    parts?: IPartSummary[];\n}\n\n/**\n *  A summary of a single part in a multi-part/form body\n */\nexport interface IPartSummary {\n    headers: { [key: string]: string[] }; // map of header name to an array of header value.\n    bodyStartIndex?: number;  // index in the multi-part payload of the first character of this part's body.\n    bodyEndIndex?: number;    // index in the multi-part payload of the first character  **after** this part's body.\n    bodyLength?: number;      // length of body in bytes\n}\n\n/**\n * set of regular expressions that match a mime type when the encoding of a payload is UTF8\n */\nconst UTF8_ENCODING_MIME_TYPES = [\n    /^text\\//,\n    /^application\\/.*?xml/,\n    /^application\\/json/,\n    /^application\\/javascript/,\n    /^application\\/x-www-form-urlencoded/,\n    /^multipart\\/form-data/\n];\n\n/**\n * Infer the encoding type given a blob\n *\n * @param blob The blob to get the encoding for\n */\nfunction getEncodingForBlob(blob: Blob) {\n    let encoding = 'none';\n    for (const mimeType of UTF8_ENCODING_MIME_TYPES) {\n        if (mimeType.test(blob.type)) {\n            encoding = 'utf8';\n            break;\n        }\n    }\n    return encoding;\n}\n\nexport function createEmptyBody(isTruncated: boolean): IBody {\n    return {\n        size: 0,\n        encoding: 'none',\n        content: '',\n        isTruncated\n    };\n}\n\nexport function getMaxHTTPBodySize(): number {\n    return getConfigSettingNumber('inspector.http.body.capture.maxsize', MAX_HTTP_BODY_SIZE);\n}\n\nexport function createBodyForBlob(contentTypeHeader: string, blob: Blob, includeParts: boolean, cb: (body: IBody) => void): void {\n    // TODO: https://github.com/Glimpse/Glimpse.Node.Prototype/issues/307\n    // Add support for base64 encoding non-text content by setting the encoding here\n\n    // Note on use of setTimeout() below.  This is done to ensure all code paths execute asynchronously,\n    // irrespective of whether convertBlobtoText is called.  For a more in-depth discussion,\n    // see https://nodejs.org/dist/latest-v7.x/docs/api/process.html#process_process_nexttick_callback_args\n\n    if (blob.size) {\n        let encoding = getEncodingForBlob(blob);\n        switch (encoding) {\n            case 'utf8':\n                convertBlobToText(blob, encoding, (content) => {\n                    const boundary = getMultiPartFormBoundary(contentTypeHeader);\n                    const parts = boundary && includeParts ? getMultiPartFormParts(boundary, content) : [];\n                    content = content.slice(0, getMaxHTTPBodySize());\n                    const bodyMessage: IBody = {\n                        size: blob.size,\n                        encoding,\n                        content,\n                        isTruncated: blob.size > content.length\n                    };\n                    if (parts && includeParts) {\n                        bodyMessage.parts = parts;\n                    }\n                    cb(bodyMessage);\n                });\n                break;\n            default:\n                setTimeout(() => cb({\n                    size: blob.size,\n                    encoding,\n                    content: '',\n                    isTruncated: true\n                }), 0);\n                break;\n        }\n    } else {\n        setTimeout(() => cb(createEmptyBody(false)), 0);\n    }\n}\n\n/**\n * Function to convert a string to a map from header-name => string[] of header values\n *\n * @param rawHeaders raw headers string\n */\nfunction convertRawHeaders(rawHeaders: string): { [key: string]: string[] } {\n    const h: { [key: string]: string[] } = {};\n    rawHeaders = rawHeaders.trim();\n    const lines = rawHeaders.split('\\r\\n');\n    lines.forEach((l) => {\n        const idx = l.indexOf(':');\n        if (idx > 0) {\n            const name = l.substring(0, idx).trim().toLowerCase();\n            const value = l.substring(idx + 1, l.length).trim();\n            if (!h[name]) {\n                h[name] = [];\n            }\n            h[name].push(value);\n        }\n    });\n\n    return h;\n}\n\n/**\n * Regular expression to pull boundary delimiter from multipart/form-data content type.\n * valid boundary characters taken from grammar defined in https://www.ietf.org/rfc/rfc2046.txt, Appendix A\n */\nconst MULTIPART_FORMDATA_REG_EX = /\\s*(multipart\\/form-data)\\s*;.*boundary\\s*=\\s*\"?([0-9a-zA-Z'()+_,-.\\/:=?]+)\"?/i;\n\n/**\n * Get the boundary delimiter for a multipart/forma-data content-type header.\n * If boundary paramter doesn't exist, or if content-type is not multipart/form-data\n * this will return undefined;\n *\n * @param contentTypeHeader the value of the Content-Type header\n */\nexport function getMultiPartFormBoundary(contentTypeHeader: string) {\n    const matches = MULTIPART_FORMDATA_REG_EX.exec(contentTypeHeader);\n    if (matches) {\n        return matches[2];\n    }\n    return undefined;\n}\n\n/**\n * Given a multipart-form/data encoded body & a boundary delimiter, this will return an\n * array of IPartSummary interfaces describing the parts.\n *\n * @param boundary The boundary delimiter string used in a multipart/form-data message\n * @param body The text body.\n */\nexport function getMultiPartFormParts(boundary: string, body: string): IPartSummary[] {\n    boundary = '--' + boundary;\n    const firstBoundaryRegExString = `^((\\\\r\\\\n)?${boundary}\\\\s*?\\\\r\\\\n)`;\n    const firstBoundaryRegEx = new RegExp(firstBoundaryRegExString, 'gm');\n\n    // captures:\n    //    $1:  optional header section\n    //    $2:  CRLFCRLF seperating headers & body, or if no headers, separating boundary marker & body\n    //    $3:  body section\n    //    $4:  next boundary marker\n    //    $5:  content after closing boundary\n    //    $6:  \"--\" indicating end of multipart bodies.  If this part matches, then we've found the last boundary delimiter\n    //    $7:  trailing whitespace\n    const partRegExString = `([\\\\s\\\\S]*?)(\\\\r\\\\n\\\\r\\\\n)([\\\\s\\\\S]*?)(\\\\r\\\\n${boundary})((--)|(\\\\s*?\\\\r\\\\n))`;\n    const partRegEx = new RegExp(partRegExString, 'gm');\n\n    const firstBoundary = firstBoundaryRegEx.exec(body);\n    const partSummaries: IPartSummary[] = [];\n    if (firstBoundary) {\n        // start searching for parts immediately after the first boundary reg ex match.  Back up two to include trailing \\r\\n\n        partRegEx.lastIndex = firstBoundaryRegEx.lastIndex - 2;\n        while (true) {\n            const part = partRegEx.exec(body);\n            if (!part) {\n                break;\n            }\n            const headerSectionLength = part[1] ? part[1].length : 0;\n            const bodyStartIndex = part.index + headerSectionLength + part[2].length;\n            const convertedHeaders = part[1] ? convertRawHeaders(part[1]) : {};\n            const bodySectionLength = part[3] ? part[3].length : 0;\n            partSummaries.push({\n                headers: convertedHeaders,\n                bodyStartIndex: part.index + part[1].length + part[2].length,\n                bodyEndIndex: bodyStartIndex + bodySectionLength,\n                bodyLength: bodySectionLength\n            });\n\n            if (part[6]) {\n                // found trailing -- after boundary, which indicates we're done\n                break;\n            }\n        }\n    }\n    return partSummaries;\n}\n\ninterface GlimpsePerformanceResourceTiming extends PerformanceResourceTiming {\n    __glimpse_requestId?: string;\n}\n\n/**\n * Asynchronously attempts to find a PerformanceResourceTiming object that matches the given initiatorType and url and\n * whose startTime is within two milliseconds of `expectedStart` parameter. Specified callback will invoked with the\n * matching PerformanceResourceTiming object, or with undefined if unable to find matching object.\n * Will attempt lookup up to 8 times, with a delay increasing exponentially from 1ms up to 256ms, for a maximum delay of 511ms\n *\n * @param initiatorType A RegExp that will match the expected value for the initiatorType of the target PerformanceResourceTiming instance\n * @param url - expected URL of the target PerformanceResourceTiming instance\n * @param expectedStart - the expected start time for the target PerformanceResourceTiming instance\n * @param cb - callback to invoke when target is found, or when max number of lookup attempts has been made\n */\nexport function tryFindResourceTimingObject(requestId: string, initiatorType: RegExp, url: string, expectedStart: number, cb: (p: PerformanceResourceTiming) => void) {\n    if (!(performance && performance.getEntriesByType)) {\n        setTimeout(() => cb(undefined));\n        return;\n    }\n\n    const maxDelay = 1024; // milliseconds\n    let delay = 1;\n\n    function tryGet() {\n        function computeDelta(p2: PerformanceResourceTiming): number {\n            return Math.abs(p2.startTime - expectedStart);\n        }\n\n        // try to find this request\n        const entries: PerformanceResourceTiming[] = performance.getEntriesByType('resource');\n        let target: GlimpsePerformanceResourceTiming = undefined;\n        let candidates: GlimpsePerformanceResourceTiming[] = [];\n        for (let i = 0; i < entries.length; i++) {\n            const curr = entries[i] as GlimpsePerformanceResourceTiming;\n            if (requestId && curr.__glimpse_requestId === requestId) {\n                // if we've already matched this PerformanceResourceTiming with this specific request, then use it\n                target = curr;\n                break;\n            }\n            else if (initiatorType.test(curr.initiatorType) && curr.name === url && expectedStart <= curr.startTime && !curr.__glimpse_requestId) {\n                candidates.push(curr);\n            }\n        }\n\n        if (!target) {\n            candidates.sort((a, b) => {\n                const deltaA = computeDelta(a);\n                const deltaB = computeDelta(b);\n\n                // sort by smallest delta between startTime & expectedStart\n                return (deltaA - deltaB);\n            });\n\n            if (candidates.length > 0) {\n                target = candidates[0];\n                target.__glimpse_requestId = requestId;\n            }\n        }\n\n        if (target || delay >= maxDelay) {\n            cb(target);\n        }\n        else {\n            delay *= 2;\n            setTimeout(tryGet, delay);\n        }\n\n        return target;\n    }\n\n    setTimeout(tryGet, delay);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/HttpRequestUtils.ts","export const MAX_HTTP_BODY_SIZE = 132000;\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/Constants.ts","import * as ErrorStackParser from 'error-stack-parser';\n\nexport interface IStackFrame {\n    fileName: string;\n    functionName: string;\n    lineNumber: number;\n    columnNumber: number;\n}\n\nexport function getStackTrace(cb: (frames: IStackFrame[]) => void): void {\n\n    // stacktrace-js library has a Get method that will try to apply sourcemaps, however\n    // that will trigger a download of the source, and will show up as an XHR request\n    // in glimpse, which we don't want.  When we disable source-maps, then\n    // stacktrace-js will reject a promise, which causes undesired debugger breakpoints\n    // when the user has their app open in f12 tools. The easiest thing here is to put\n    // generate the error ourself, and use the error-stack-parser library to parse the\n    // error into stack frames.\n\n    // this logic to get an error comes from stacktrace-js library.\n    // See https://github.com/stacktracejs/stacktrace.js/blob/master/stacktrace.js#L25-L32\n    function getError() {\n        let err = new Error();\n        if (!err.stack) {\n            try {\n                // Error must be thrown to get stack in IE\n                throw new Error();\n            } catch (e2) {\n                err = e2;\n            }\n        }\n        return err;\n    }\n\n    let stackFrames = ErrorStackParser.parse(getError());\n\n    // slice off top frames where glimpse code is on the stack.\n    for (let i = 0; i < stackFrames.length; i++) {\n        if (stackFrames[i].fileName && !stackFrames[i].fileName.endsWith('/glimpse/agent/agent.js?hash={hash}')) {\n            stackFrames = stackFrames.slice(i);\n            break;\n        }\n    }\n\n    // strip out any extra properties we don't want to send w/ the glimpse message\n    const newFrames: IStackFrame[] = [];\n    stackFrames.forEach((val: ErrorStackParser.StackFrame, index: number) => {\n        newFrames[index] = {\n            fileName: val.fileName,\n            functionName: val.functionName,\n            lineNumber: val.lineNumber,\n            columnNumber: val.columnNumber\n        };\n    });\n\n    // various tests are expecting this to run asynchronously, which we'll eventually need if we ever hook up\n    // source maps.  Even though we don't need it today, we'll leave this as an async function.\n    window.setTimeout(() => { cb(newFrames); }, 0);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/CallStackUtilities.ts","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: fileName,\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame({\n                        functionName: line\n                    });\n                } else {\n                    var tokens = line.split('@');\n                    var locationParts = this.extractLocation(tokens.pop());\n                    var functionName = tokens.join('@') || undefined;\n\n                    return new StackFrame({\n                        functionName: functionName,\n                        fileName: locationParts[0],\n                        lineNumber: locationParts[1],\n                        columnNumber: locationParts[2],\n                        source: line\n                    });\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame({\n                            functionName: match[3] || undefined,\n                            fileName: match[2],\n                            lineNumber: match[1],\n                            source: lines[i]\n                        })\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return filtered.map(function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n\n                return new StackFrame({\n                    functionName: functionName,\n                    args: args,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        }\n    };\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/error-stack-parser/error-stack-parser.js\n// module id = 19\n// module chunks = 0","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function() {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function _capitalize(str) {\n        return str[0].toUpperCase() + str.substring(1);\n    }\n\n    function _getter(p) {\n        return function() {\n            return this[p];\n        };\n    }\n\n    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    var numericProps = ['columnNumber', 'lineNumber'];\n    var stringProps = ['fileName', 'functionName', 'source'];\n    var arrayProps = ['args'];\n\n    var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n    function StackFrame(obj) {\n        if (obj instanceof Object) {\n            for (var i = 0; i < props.length; i++) {\n                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n                    this['set' + _capitalize(props[i])](obj[props[i]]);\n                }\n            }\n        }\n    }\n\n    StackFrame.prototype = {\n        getArgs: function() {\n            return this.args;\n        },\n        setArgs: function(v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        getEvalOrigin: function() {\n            return this.evalOrigin;\n        },\n        setEvalOrigin: function(v) {\n            if (v instanceof StackFrame) {\n                this.evalOrigin = v;\n            } else if (v instanceof Object) {\n                this.evalOrigin = new StackFrame(v);\n            } else {\n                throw new TypeError('Eval Origin must be an Object or StackFrame');\n            }\n        },\n\n        toString: function() {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {\n            return function(v) {\n                this[p] = Boolean(v);\n            };\n        })(booleanProps[i]);\n    }\n\n    for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {\n            return function(v) {\n                if (!_isNumber(v)) {\n                    throw new TypeError(p + ' must be a Number');\n                }\n                this[p] = Number(v);\n            };\n        })(numericProps[j]);\n    }\n\n    for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {\n            return function(v) {\n                this[p] = String(v);\n            };\n        })(stringProps[k]);\n    }\n\n    return StackFrame;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stackframe/stackframe.js\n// module id = 20\n// module chunks = 0","import logger from '../common/GlimpseLogger';\nimport { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { addOffset } from '../common/MessageMixins';\nimport {\n    IRequestSentEvent, EVENT_FETCH_REQUEST_SENT,\n    IResponseReceivedEvent, EVENT_FETCH_RESPONSE_RECEIVED,\n    EVENT_FETCH_ERROR\n} from '../tracing/proxies/FetchProxy';\nimport tracing from '../tracing/Tracing';\nimport { getDateTime } from '../common/DateTimeUtilities';\nimport { parseUrl, getHeaderKeys } from '../common/RequestUtilities';\nimport {\n    tryFindResourceTimingObject,\n    IBody,\n    IPartSummary,\n    getMultiPartFormBoundary,\n    getMultiPartFormParts,\n    createBodyForBlob,\n    createEmptyBody\n} from './HttpRequestUtils';\nimport { getStackTrace } from '../common/CallStackUtilities';\n\ninterface IRequestCacheEntry {\n    startTimeStamp: number;\n    startTimeOffset: number;\n}\n\nexport class FetchInspector implements IInspector {\n\n    private initiatorRexExp = /(^$)|(other)/i;\n\n    private messagePublisher: IMessagePublisher;\n\n    private requests: { [id: string]: IRequestCacheEntry } = {};\n\n    private createHeaders(headers: Headers): { [header: string]: string } {\n        const parsedHeaders = {};\n        const headerKeys = getHeaderKeys(headers);\n        for (const header of headerKeys) {\n            parsedHeaders[header] = headers.get(header);\n        }\n        return parsedHeaders;\n    }\n\n    private getContentTypeHeader(headers: Headers): string {\n        let val: string;\n        val = headers.get('content-type');\n        if (!val) {\n            const headerKeys = getHeaderKeys(headers);\n            for (const header of headerKeys) {\n                if (header.toLowerCase() === 'content-type') {\n                    val = headers[header];\n                    break;\n                }\n            }\n        }\n        return val;\n    }\n\n    private before(event: IProxyEvent) {\n        const eventData: IRequestSentEvent = event.data;\n\n        getStackTrace((frames) => {\n            const publishMessage = (body: IBody) => {\n                const url = parseUrl(eventData.request.url);\n                const startTime = getDateTime(new Date(event.timeStamp));\n                const msg = this.messagePublisher.createMessage(['data-http-request', 'call-stack'], {\n                    correlationId: eventData.id,\n                    protocol: {\n                        identifier: url.protocol.replace(/\\:$/, '').toLowerCase()\n                    },\n                    url: eventData.request.url,\n                    method: eventData.request.method,\n                    startTime,\n                    timing: {\n                        startTime: 0\n                    },\n                    headers: this.createHeaders(eventData.request.headers),\n                    isAjax: true,\n                    body,\n                    frames: frames.slice(0, 1)\n                });\n                addOffset(event.offset, msg);\n                this.messagePublisher.publishMessage(msg);\n            };\n\n            eventData.request\n                .blob()\n                .then(\n                blob => {\n                    const contentTypeHeader = this.getContentTypeHeader(eventData.request.headers);\n                    createBodyForBlob(contentTypeHeader, blob, true, body => {\n                        publishMessage(body);\n                    });\n                },\n                reason => {\n                    // Safari 10.1 fails to obtain the request body as a blob, so publish the message with a \"truncated\" body...\n                    // (https://github.com/Glimpse/Glimpse.Browser.Agent/issues/192)\n                    publishMessage(createEmptyBody(/* truncated: */ true));\n                });\n        });\n    }\n\n    private after(event: IProxyEvent, requestEntry: IRequestCacheEntry) {\n        const eventData: IResponseReceivedEvent = event.data;\n        eventData.response.blob().then((blob) => {\n            const responseEndOffset = performance.now();\n\n            // for fetch events, the initiator type is an empty string on chrome, and 'other' on firefox.\n\n            tryFindResourceTimingObject(event.data.id, this.initiatorRexExp, event.data.response.url, requestEntry.startTimeOffset, (timings: PerformanceResourceTiming) => {\n\n                // we make a best-effort to find the PerformanceResourceTiming instance associated with this request.  If we have one,\n                // we use it, but if not, we fall back to using times associated with when different proxy methods were invoked\n                const offset = timings ? timings.startTime : requestEntry.startTimeOffset;\n                const startTime = 0;\n                // leave responseStart undefined if no timings instance since this is optional and we don't know accurate value\n                const responseStart = timings && (timings.responseStart >= timings.startTime) ? (timings.responseStart - timings.startTime) : undefined;\n                const responseEnd = timings ? (timings.responseEnd - timings.startTime) : (responseEndOffset - requestEntry.startTimeOffset);\n\n                const contentTypeHeader = this.getContentTypeHeader(eventData.response.headers);\n                createBodyForBlob(contentTypeHeader, blob, true, (body) => {\n                    let statusCode: number;\n                    switch (eventData.response.type) {\n                        case 'error':\n                            // TODO: publish an error message here. See https://github.com/Glimpse/Glimpse.Browser.Agent/issues/134\n                            return;\n                        case 'opaque':\n                            statusCode = -1;\n                            break;\n                        case 'opaqueredirect':\n                            statusCode = -2;\n                            break;\n                        default:\n                            statusCode = eventData.response.status;\n                            break;\n                    }\n\n                    const msg = this.messagePublisher.createMessage('data-http-response', {\n                        correlationId: eventData.id,\n                        url: eventData.response.url,\n                        headers: this.createHeaders(eventData.response.headers),\n                        statusCode,\n                        statusMessage: eventData.response.statusText,\n                        endTime: getDateTime(new Date(event.timeStamp)),\n                        duration: responseEnd,\n                        timing: {\n                            startTime,\n                            responseEnd\n                        },\n                        body\n                    });\n\n                    if (responseStart !== undefined) {\n                        msg.payload.timing.responseStart = responseStart;\n                    }\n\n                    addOffset(offset, msg);\n                    this.messagePublisher.publishMessage(msg);\n                });\n            });\n        });\n    }\n\n    public numOutstandingRequests() {\n        return Object.keys(this.requests).length;\n    }\n\n    public init(messagePublisher: IMessagePublisher) {\n        this.messagePublisher = messagePublisher;\n\n        tracing.on(EVENT_FETCH_REQUEST_SENT, (event: IProxyEvent) => {\n            this.requests[event.data.id] = {\n                startTimeStamp: event.timeStamp,\n                startTimeOffset: event.offset\n            };\n            this.before(event);\n        });\n\n        tracing.on(EVENT_FETCH_RESPONSE_RECEIVED, (event: IProxyEvent) => {\n            const requestEntry = this.requests[event.data.id];\n            if (!requestEntry) {\n                logger.error('Glimpse Internal Error: could not find associated master data, some inspection data will be lost.');\n                return;\n            }\n            this.after(event, requestEntry);\n            delete this.requests[event.data.id];\n        });\n\n        tracing.on(EVENT_FETCH_ERROR, (data: IProxyEvent) => {\n            delete this.requests[data.data.id];\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/FetchInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getGuid } from '../../common/GeneralUtilities';\n\n/**\n * This event indicates that a request was sent, as indicated by a call to\n * `self.fetch()`\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {Request} request - A request object representing the user request.\n *      Note: this is always a request object, regardless of how the fetch API\n *      was called. If a request object was passed to the `fetch()` method, this\n *      request object is a clone of that one, not the original instance.\n */\nexport interface IRequestSentEvent {\n    id: string;\n    request: Request;\n}\nexport const EVENT_FETCH_REQUEST_SENT = 'invoke|pre|fetch.request-sent';\n\n/**\n * This event indicates that a response was received. This event is fired when\n * the promise returned from a call to `self.fetch()` is resolved (not rejected).\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {Response} response - The response object. Note: this response object\n *      is a cloned copy of the response object that the original promise returned,\n *      not the original instance.\n */\nexport interface IResponseReceivedEvent {\n    id: string;\n    response: Response;\n}\nexport const EVENT_FETCH_RESPONSE_RECEIVED = 'notify|fetch.response-received';\n\n/**\n * This event indicates an error happened during the request, which is done\n * by waiting for the promise returned by `fetch()` to reject. There is a caveat\n * though: rejections caused by malformed input does _not_ cause an error event\n * to be emitted. This is by design, as this error condition means no request\n * was ever sent at all, even if the promise returned from `fetch()` _does_ reject.\n *\n * @property {string} id - An ID that is consistent for all stages of this request\n * @property {XMLHttpRequest} xhr - The XMLHttpRequest instance\n * @property {error} error - A description of the error, if one is available\n */\nexport interface IErrorEvent {\n    id: string;\n    error: string | Error;\n}\nexport const EVENT_FETCH_ERROR = 'notify|fetch.error';\n\n/**\n * Proxy which wraps fetch usage and its various supporting functions.\n *\n * NOTE: Don't add any headers within this proxy, breaks CORS scenarioes.\n */\nexport class FetchProxy implements IProxy {\n    public isSupported(): boolean {\n        return !!(self && typeof self.fetch !== 'undefined');\n    }\n\n    public init() {\n        // Note: we use `self` instead of `window` in case we're in a worker thread\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n\n        // Only initialize if this browser supports the Fetch API\n        if (self.fetch) {\n            const oldFetch = self.fetch;\n            self.fetch = function fetch(input, init, ...args) {\n                // Create a request object if one wasn't specified, or clone the\n                // existing one if it was so we can safely read the body.\n                let request;\n                if (input instanceof Request) {\n                    request = input.clone();\n                } else {\n                    // OK, so I know this looks weird, but the use of Promises\n                    // here provides a unique challenge. If you instantiate a\n                    // Request object directly, it will throw an exception if the\n                    // input is malformed. However, the `fetch()` API is wrapped\n                    // in a promise, which means malformed input does _not_ throw\n                    // when passed to `fetch()`. Instead it causes the promise to\n                    // reject. We do _not_ want to pick up on this case though,\n                    // because we would otherwise publish an ERROR_EVENT, which\n                    // we do _not_ want in this case. So we detect malformed input,\n                    // and return the promise directly without listening to it.\n                    try {\n                        request = new Request(input, init);\n                    } catch (e) {\n                        return oldFetch.call(this, input, init, ...args);\n                    }\n                }\n\n                const id = getGuid();\n\n                // Publish the request message\n                const requestSentEventData: IRequestSentEvent = {\n                    id,\n                    request\n                };\n                tracing.publish(EVENT_FETCH_REQUEST_SENT, requestSentEventData);\n\n                // Call the original fetch method. We wait for the response to be\n                // received using the promise, and publish the resulting\n                const fetchPromise = oldFetch.call(this, input, init, ...args);\n                fetchPromise.then((response) => {\n                    const responseReceivedEventData: IResponseReceivedEvent = {\n                        id,\n                        response: response.clone()\n                    };\n                    tracing.publish(EVENT_FETCH_RESPONSE_RECEIVED, responseReceivedEventData);\n                }, (error) => {\n                    const errorEventData: IErrorEvent = {\n                        id,\n                        error\n                    };\n                    tracing.publish(EVENT_FETCH_ERROR, errorEventData);\n                });\n\n                return fetchPromise;\n            };\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/FetchProxy.ts","import { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { EVENT_RESOURCE_TIMING_COLLECTED } from '../tracing/proxies/ResourceTimingProxy';\nimport tracing from '../tracing/Tracing';\n\nexport class ResourceTimingInspector implements IInspector {\n    public init(messagePublisher: IMessagePublisher) {\n        tracing.on(EVENT_RESOURCE_TIMING_COLLECTED, (event: IProxyEvent) => {\n            // TODO: Eventually, we'll add more logic here to clean up data in\n            // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n            messagePublisher.createAndPublishMessage('browser-resource', {\n                timings: event.data\n            });\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/ResourceTimingInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getMessageIngressUrl } from '../../common/RequestUtilities';\nimport performance from '../../common/PerformanceUtilities';\n\nconst UPDATE_INTERVAL = 1000;\n\n/**\n * @property {string} name - The fully resolved URL of the resource\n * @property {number} startTime - The amount of time that has elapsed since the\n *      time origin of the browser, typically page load\n * @property {number} duration - The amount of time it took to fetch the resource\n * @property {string} initiatorType - The type of resource, e.g. 'css', 'img', etc.\n * @property {string} nextHopProtocol - The protocol used by the browser to fetch\n *      the resource, e.g. 'HTTP/1'\n * @property {number} redirectStart - The timestamp of the start of a redirect\n * @property {number} redirectEnd - The timestamp of the end of a redirect\n * @property {number} fetchStart - The timestamp of the start of a fetch request\n * @property {number} domainLookupStart - The timestamp of the start of a DNS lookup\n * @property {number} domainLookupEnd - The timestamp of the end of a DNS lookup\n * @property {number} connectStart - The timestamp of the start of a TCP connection\n *      being made\n * @property {number} connectEnd - The timestamp of the end of a TCP connection\n *      being made\n * @property {number} secureConnectionStart - The timestamp of the start of a\n *      secure TLS connection being made\n * @property {number} requestStart - The timestamp of the start the HTTP request\n * @property {number} responseStart - The timestamp of the start the HTTP response\n * @property {number} responseEnd - The timestamp of the end the HTTP response\n * @property {number} transferSize - The size of the entire response, including headers, body, etc.\n * @property {number} encodedBodySize - The size of the response body before decoding, e.g. gzipped size\n * @Property {number} decodedBodySize - The size of the response body after decoding\n */\nexport interface IResourceTimingCollectionEvent {\n    name: string;\n    startTime: number;\n    duration: number;\n    initiatorType: string;\n    nextHopProtocol: string;\n    redirectStart: number;\n    redirectEnd: number;\n    fetchStart: number;\n    domainLookupStart: number;\n    domainLookupEnd: number;\n    connectStart: number;\n    connectEnd: number;\n    secureConnectionStart: number;\n    requestStart: number;\n    responseStart: number;\n    responseEnd: number;\n    transferSize: number;\n    encodedBodySize: number;\n    decodedBodySize: number;\n}\nexport const EVENT_RESOURCE_TIMING_COLLECTED = 'notify|performance.resource-collected';\n\nexport class ResourceTimingProxy implements IProxy {\n    public isSupported(): boolean {\n        // Don't initialize if this browser doesn't support resource timing\n        return !!(performance && performance.getEntriesByType);\n    }\n\n    public init() {\n        function processEntry(entry): IResourceTimingCollectionEvent {\n            // This sheds any extra properties that may be introduced to resource timing\n            // or are browser specific, and ensures the data matches our interface for it.\n            return {\n                name: entry.name,\n                startTime: entry.startTime,\n                duration: entry.duration,\n                initiatorType: entry.initiatorType,\n                nextHopProtocol: entry.nextHopProtocol,\n                redirectStart: entry.redirectStart,\n                redirectEnd: entry.redirectEnd,\n                fetchStart: entry.fetchStart,\n                domainLookupStart: entry.domainLookupStart,\n                domainLookupEnd: entry.domainLookupEnd,\n                connectStart: entry.connectStart,\n                connectEnd: entry.connectEnd,\n                secureConnectionStart: entry.secureConnectionStart,\n                requestStart: entry.requestStart,\n                responseStart: entry.responseStart,\n                responseEnd: entry.responseEnd,\n                transferSize: entry.transferSize,\n                encodedBodySize: entry.encodedBodySize,\n                decodedBodySize: entry.decodedBodySize\n            };\n        }\n\n        // Eventually we want to switch to using Performance Observers once browsers\n        // start to implement, but currently none do, so we poll for entries instead\n        // https://w3c.github.io/performance-timeline/#dom-performanceobserver\n        const reportedEntries = {};\n        function record() {\n            const resources = performance.getEntriesByType('resource');\n            const entriesToPublish = [];\n            const ingressUrl = getMessageIngressUrl();\n            for (const resource of resources) {\n                // Create a unique id for the entry, a combination of the start time\n                // and resolved URL\n                const id = `${resource.startTime}#${resource.name}`;\n                if (!reportedEntries[id] && resource.name.indexOf(ingressUrl) === -1) {\n                    reportedEntries[id] = true;\n                    entriesToPublish.push(processEntry(resource));\n                }\n            }\n            if (entriesToPublish.length) {\n                tracing.publish(EVENT_RESOURCE_TIMING_COLLECTED, entriesToPublish);\n            }\n            setTimeout(record, UPDATE_INTERVAL);\n        };\n        record();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/ResourceTimingProxy.ts","function getPerformance(): Performance {\n    // tslint:disable:no-any\n    return window.performance ||\n        (<any>window).webkitPerformance ||\n        (<any>window).msPerformance ||\n        (<any>window).mozPerformance;\n}\n\nexport default getPerformance();\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/PerformanceUtilities.ts","import { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport { EVENT_NAVIGATION_TIMING_COLLECTED, INavigationTimingCollectionEvent } from '../tracing/proxies/NavigationTimingProxy';\nimport tracing from '../tracing/Tracing';\n\nexport class NavigationTimingInspector implements IInspector {\n    public init(messagePublisher: IMessagePublisher) {\n        tracing.on(EVENT_NAVIGATION_TIMING_COLLECTED, (event: IProxyEvent) => {\n            const data: INavigationTimingCollectionEvent = event.data;\n            const message = {\n                loadDuration: data.loadEventEnd - data.fetchStart,\n                // time spent constructing the DOM tree\n                domReadyDuration: data.domComplete - data.domInteractive,\n                // time consumed preparing the new page\n                readyStartDuration: data.fetchStart - data.navigationStart,\n                // time spent during redirection\n                redirectDuration: data.redirectEnd - data.redirectStart,\n                // appCache\n                appcacheDuration: data.domainLookupStart - data.fetchStart,\n                // time spent unloading documents\n                unloadEventDuration: data.unloadEventEnd - data.unloadEventStart,\n                // DNS query time\n                lookupDomainDuration: data.domainLookupEnd - data.domainLookupStart,\n                // TCP connection time\n                connectDuration: data.connectEnd - data.connectStart,\n                // time spent during the request\n                requestDuration: data.responseEnd - data.requestStart,\n                // request to completion of the DOM loading\n                initDomTreeDuration: data.domInteractive - data.responseEnd,\n                // load event time\n                loadEventDuration: data.loadEventEnd - data.loadEventStart,\n\n                // time spent on the network making the outgoing request\n                networkRequestDuration: data.requestStart - data.navigationStart,\n                // time spent on the network receiving the incoming response\n                networkResponseDuration: data.responseEnd - data.responseStart,\n                // time spent on the server processing the request\n                serverDuration: data.responseEnd - data.requestStart,\n                // time spent on the browser handling the response\n                browserDuration: data.loadEventEnd - data.responseStart,\n                // total time\n                totalDuration: data.loadEventEnd - data.navigationStart,\n\n                ...event.data\n            };\n            // time spent on the network for the whole request/response\n            message.networkDuration = message.networkRequestDuration + message.networkResponseDuration;\n\n            // TODO: Eventually, we'll add more logic here to clean up data in\n            // https://github.com/Glimpse/Glimpse.Browser.Agent/issues/29.\n            messagePublisher.createAndPublishMessage('browser-navigation-timing', message);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/NavigationTimingInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport { getMessageIngressUrl } from '../../common/RequestUtilities';\nimport performance from '../../common/PerformanceUtilities';\nimport { addEvent } from '../../common/RequestUtilities';\n\nexport interface INavigationTimingCollectionEvent {\n    connectEnd: number;\n    connectStart: number;\n    domComplete: number;\n    domContentLoadedEventEnd: number;\n    domContentLoadedEventStart: number;\n    domInteractive: number;\n    domLoading: number;\n    domainLookupEnd: number;\n    domainLookupStart: number;\n    fetchStart: number;\n    firstPaint: number;\n    firstPaintDuration?: number;\n    loadEventEnd: number;\n    loadEventStart: number;\n    navigationStart: number;\n    redirectEnd: number;\n    redirectStart: number;\n    requestStart: number;\n    responseEnd: number;\n    responseStart: number;\n    secureConnectionStart: number;\n    unloadEventEnd: number;\n    unloadEventStart: number;\n}\nexport const EVENT_NAVIGATION_TIMING_COLLECTED = 'notify|performance.navigation-timing';\n\nexport class NavigationTimingProxy implements IProxy {\n    public isSupported(): boolean {\n        return !!(performance && performance.timing);\n    }\n\n    public init() {\n        // setup/regiter strategy to run later\n        addEvent(window, 'load', () => {\n            setTimeout(() => {\n                this.processTimings(performance.timing);\n            });\n        });\n    }\n\n    private processEntry(entry: PerformanceTiming): INavigationTimingCollectionEvent {\n        // This sheds any extra properties that may be introduced to navigation\n        // timing or are browser specific, and ensures the data matches our\n        // interface for it.\n        return {\n            connectEnd: entry.connectEnd,\n            connectStart: entry.connectStart,\n            domComplete: entry.domComplete,\n            domContentLoadedEventEnd: entry.domContentLoadedEventEnd,\n            domContentLoadedEventStart: entry.domContentLoadedEventStart,\n            domInteractive: entry.domInteractive,\n            domLoading: entry.domLoading,\n            domainLookupEnd: entry.domainLookupEnd,\n            domainLookupStart: entry.domainLookupStart,\n            fetchStart: entry.fetchStart,\n            firstPaint: (<any>entry).firstPaint,  //tslint:disable-line:no-any\n            firstPaintDuration: 0,\n            loadEventEnd: entry.loadEventEnd,\n            loadEventStart: entry.loadEventStart,\n            navigationStart: entry.navigationStart,\n            redirectEnd: entry.redirectEnd,\n            redirectStart: entry.redirectStart,\n            requestStart: entry.requestStart,\n            responseEnd: entry.responseEnd,\n            responseStart: entry.responseStart,\n            // NOTE: Firefox and Edge will not always provide a value for secureConnectionStart.\n            secureConnectionStart: entry.secureConnectionStart || 0,\n            unloadEventEnd: entry.unloadEventEnd,\n            unloadEventStart: entry.unloadEventStart\n        };\n    }\n\n    private processTimings(timing: PerformanceTiming) {\n        const eventData = this.processEntry(timing);\n\n        // time to first paint\n        // tslint:disable-next-line:no-any\n        if ((<any>eventData).firstPaint === undefined) {\n            // All times are relative times to the start time within the\n            // same objects\n            let firstPaint = 0;\n            let firstPaintDuration = 0;\n\n            //tslint:disable-next-line:no-any\n            if ((<any>window).chrome && (<any>window).chrome.loadTimes) {\n                //tslint:disable-next-line:no-any\n                const loadTimes = (<any>window).chrome.loadTimes();\n                firstPaint = loadTimes.firstPaintTime * 1000;\n                firstPaintDuration = firstPaint - loadTimes.startLoadTime * 1000;\n            } else if (typeof timing.msFirstPaint === 'number') {\n                firstPaint = timing.msFirstPaint;\n                firstPaintDuration = firstPaint - timing.navigationStart;\n            }\n            eventData.firstPaint = firstPaint;\n            eventData.firstPaintDuration = firstPaintDuration;\n        }\n\n        tracing.publish(EVENT_NAVIGATION_TIMING_COLLECTED, eventData);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/NavigationTimingProxy.ts","import { NOTIFY_CONSOLE_EVENT_OCCURED, IConsoleEvent } from '../tracing/proxies/ConsoleProxy';\n\nimport { IInspector } from './IInspector';\nimport { IMessagePublisher, IMessage } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport tracing from '../tracing/Tracing';\nimport { getGuid } from '../common/GeneralUtilities';\nimport { addCorrelationBegin, addCorrelationEnd, addOffset } from '../common/MessageMixins';\nimport { getStackTrace } from '../common/CallStackUtilities';\n\nexport enum LogMessageTypes {\n    json,\n    xml,\n    table,\n    assert,\n    count,\n    timespan_begin,\n    timespan_end,\n    group_begin,\n    group_end\n}\n\ninterface IConsoleData {\n    method: string;\n    arguments: any[]; // tslint:disable-line:no-any\n    offset: number;\n}\n\ninterface InspectionMethods {\n    [key: string]: {\n        level: string;\n        nullByPass?: boolean,\n        tokenTypeByPass?: boolean,\n        processor?: (message: IMessage, data: IConsoleData) => boolean | void;\n    };\n}\n\nexport class ConsoleInspector implements IInspector {\n    private countMap = {};\n\n    private stack = {\n        group: [],\n        profile: []\n    };\n\n    private map = {\n        time: {}\n    };\n\n    private mapNull = {\n        time: undefined\n    };\n\n    public methods: InspectionMethods = {\n        assert: {\n            level: 'Error',\n            processor: (message, data) => this.assert(message, data)\n        },\n        count: {\n            level: 'Debug',\n            processor: (message, data) => this.count(message, data),\n            tokenTypeByPass: true\n        },\n        debug: {\n            level: 'Debug',\n            nullByPass: true\n        },\n        dir: {\n            level: 'Log',\n            nullByPass: true,\n            processor: (message, data) => this.dir(message, data, LogMessageTypes.json),\n            tokenTypeByPass: true\n        },\n        dirxml: {\n            level: 'Log',\n            nullByPass: true,\n            processor: (message, data) => this.dir(message, data, LogMessageTypes.xml),\n            tokenTypeByPass: true\n        },\n        error: {\n            level: 'Error',\n            nullByPass: true\n        },\n        group: {\n            level: undefined,\n            processor: (message, data) => this.groupStart(message, data, false)\n        },\n        groupCollapsed: {\n            level: undefined,\n            processor: (message, data) => this.groupStart(message, data, true)\n        },\n        groupEnd: {\n            level: undefined,\n            processor: (message, data) => this.groupEnd(message, data)\n        },\n        info: {\n            level: 'Info',\n            nullByPass: true\n        },\n        log: {\n            level: 'Log',\n            nullByPass: true\n        },\n        profile: {\n            level: 'Debug',\n            processor: (message, data) => this.profileStart(message, data),\n            tokenTypeByPass: true\n        },\n        profileEnd: {\n            level: 'Debug',\n            processor: (message, data) => this.profileEnd(message, data),\n            tokenTypeByPass: true\n        },\n        table: {\n            level: 'Log',\n            nullByPass: true,\n            processor: (message, data) => this.applyType(message, data, LogMessageTypes.table),\n            tokenTypeByPass: true\n        },\n        time: {\n            level: 'Debug',\n            processor: (message, data) => this.mapStart('time', message, data, LogMessageTypes.timespan_begin),\n            tokenTypeByPass: true\n        },\n        timeEnd: {\n            level: 'Debug',\n            processor: (message, data) => this.mapEnd('time', message, data, LogMessageTypes.timespan_end),\n            tokenTypeByPass: true\n        },\n        timeStamp: {\n            level: 'Debug',\n            processor: (message, data) => this.timeStamp(message, data),\n            tokenTypeByPass: true\n        },\n        trace: {\n            level: 'Debug',\n            processor: (message, data) => this.trace(message, data)\n        },\n        warn: {\n            level: 'Warning',\n            nullByPass: true\n        }\n    };\n\n    public init(messagePublisher: IMessagePublisher) {\n        tracing.on(NOTIFY_CONSOLE_EVENT_OCCURED, (event: IProxyEvent) => {\n            const data: IConsoleEvent = event.data;\n\n            const payload: IConsoleData = {\n                method: data.method,\n                arguments: data.arguments,\n                offset: event.offset\n            };\n\n            this.publishMessage(messagePublisher, payload);\n        });\n    }\n\n    private publishMessage(messagePublisher: IMessagePublisher, data: IConsoleData) {\n        const info = this.methods[data.method];\n\n        // in the case where we have no args or a nullByPass is in effect then we shouldn't log messages\n        if (!data.arguments || data.arguments.constructor !== Array || (info.nullByPass && data.arguments.length === 0)) {\n            return;\n        }\n\n        // build base message\n        const payload = {\n            message: data.arguments,\n            library: 'Browser Console',\n            level: info.level\n        };\n        const message = messagePublisher.createMessage('log-write', payload);\n        addOffset(data.offset, message);\n\n        // run through any custom processors\n        let suppressMessage = false;\n        if (info.processor) {\n            suppressMessage = info.processor(message, data) || false;\n        }\n\n        // normalize token format\n        if (!info.tokenTypeByPass) {\n            this.deriveTokenType(message);\n        }\n\n        if (!suppressMessage) {\n            getStackTrace((frames) => {\n                message.payload.frames = frames;\n                message.types.push('call-stack');\n                messagePublisher.publishMessage(message);\n            });\n        }\n    }\n\n    // api specific targets\n\n    private count(message, data: IConsoleData) {\n        // chrome treats no args the same as ''\n        const label = data.arguments.length > 0 ? String(data.arguments[0]) : '';\n\n        // for record the label\n        message.payload.message = label;\n\n        // track ongoing progress\n        let currentCount = (this.countMap[label] || 0) + 1;\n        this.countMap[label] = currentCount;\n\n        // record the applyType\n        this.applyType(message, data, LogMessageTypes.count);\n\n        // record the addition count data\n        message.payload.count = currentCount;\n    }\n\n    private assert(message, data: IConsoleData) {\n        const assertion = data.arguments.length > 0 ? data.arguments[0] : false;\n        // if we have no args|null|undefined|0 we will treat it as a fail\n        if (assertion) {\n            return true;\n        }\n        else {\n            message.payload.message = message.payload.message.slice(1);\n        }\n    }\n\n    private dir(message, data: IConsoleData, type: LogMessageTypes) {\n        let newArgs: any = data.arguments.length > 0 ? [data.arguments[0]] : data.arguments; // tslint:disable-line:no-any\n\n        let processAsDir = false;\n\n        let value = newArgs[0];\n        if (type === LogMessageTypes.xml && value && typeof value === 'object' && value.getElementsByTagName && 'outerHTML' in value) {\n            const nodeCount = value.getElementsByTagName('*').length;\n            // Safety checks to deal with large data payloads\n            if (nodeCount > 100) {\n                newArgs = 'Node with more than `100` decendents aren\\'t supported.';\n            }\n            else {\n                value = value.outerHTML;\n                if (value.length > 2500) {\n                    newArgs = 'Node with more than `2500` characters aren\\'t supported.';\n                }\n                else {\n                    newArgs[0] = value;\n                }\n            }\n\n            processAsDir = true;\n        }\n        else if (type === LogMessageTypes.json) {\n            processAsDir = true;\n        }\n\n        // this is setup this way so that in non valid `LogMessageTypes.xml` cases, we essentually\n        // treat it as plain console.log\n        if (processAsDir) {\n            // we only care about the first arg in this case\n            message.payload.message = newArgs;\n\n            this.applyType(message, data, type);\n        }\n        else {\n            this.deriveTokenType(message);\n        }\n    }\n\n    private timeStamp(message, data: IConsoleData) {\n        this.getAndApplyLabel(message, data);\n    }\n\n    private groupStart(message, data: IConsoleData, isCollapsed: boolean) {\n        message.payload.isCollapsed = isCollapsed;\n\n        this.stackStart('group', message, data, LogMessageTypes.group_begin);\n    }\n\n    private groupEnd(message, data: IConsoleData) {\n        return this.stackEnd('group', message, data, LogMessageTypes.group_end);\n    }\n\n    private profileStart(message, data: IConsoleData) {\n        this.getAndApplyLabel(message, data);\n\n        this.stackStart('profile', message, data, LogMessageTypes.timespan_begin);\n    }\n\n    private profileEnd(message, data: IConsoleData) {\n        this.getAndApplyLabel(message, data);\n\n        const result = this.stackEnd('profile', message, data, LogMessageTypes.timespan_end);\n\n        return result;\n    }\n\n    private trace(message, data: IConsoleData) {\n        // for trace methods include 'log-display-callstack' message type so callstack will be displayed\n        message.types.push('log-display-callstack');\n\n        // make a copy of the message since we're going to modify it.\n        message.payload.message = Array.prototype.slice.call(message.payload.message, 0);\n        if (message.payload.message[0] === undefined) {\n            message.payload.message[0] = 'Trace:';\n        }\n        else {\n            message.payload.message[0] = 'Trace: ' + message.payload.message[0];\n        }\n    }\n\n    // common/shared helpers\n\n    private applyType(message, data: IConsoleData, mixin: LogMessageTypes) {\n        const type = LogMessageTypes[mixin].replace('_', '-');\n\n        message.types.push('log-' + type);\n    }\n\n    private getAndApplyLabel(message, data: IConsoleData) {\n        const label = data.arguments.length > 0 ? String(data.arguments[0]) : undefined;\n\n        // for mapEnds we dump the args and just use the label\n        message.payload.message = label;\n\n        return label;\n    }\n\n    private stackStart(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const group = this.coreStart(message, data, mixin);\n\n        this.stack[type].push(group);\n    }\n\n    private stackEnd(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const group = this.stack[type].pop();\n        if (group) {\n            this.coreEnd(group, message, data, mixin);\n        }\n        else {\n            return true;\n        }\n    }\n\n    private mapStart(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const label = this.getAndApplyLabel(message, data);\n\n        const group = this.coreStart(message, data, mixin);\n\n        if (label !== undefined) {\n            this.map[type][label] = group;\n        }\n        else {\n            this.mapNull[type] = group;\n        }\n    }\n\n    private mapEnd(type, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const label = this.getAndApplyLabel(message, data);\n\n        let group = label !== undefined ? this.map[type][label] : this.mapNull[type];\n        if (group) {\n            if (label !== undefined) {\n                delete this.map[type][label];\n            }\n            else {\n                this.mapNull[type] = undefined;\n            }\n        }\n        else {\n            // if no match is found we should match to page load\n            group = { correlationId: getGuid(), time: 0 };\n        }\n\n        this.coreEnd(group, message, data, mixin);\n    }\n\n    private coreStart(message, data: IConsoleData, mixin: LogMessageTypes) {\n        const correlationId = getGuid();\n        const time = data.offset;\n\n        addCorrelationBegin(correlationId, message);\n\n        // add action begin specific data\n        this.applyType(message, data, mixin);\n\n        return {\n            correlationId: correlationId,\n            time: time\n        };\n    }\n\n    private coreEnd(group, message, data: IConsoleData, mixin: LogMessageTypes) {\n        const time = data.offset;\n\n        // add action begin specific data\n        this.applyType(message, data, mixin);\n\n        addCorrelationEnd(group.correlationId, time - group.time, message);\n    }\n\n    private deriveTokenType(message) {\n        if (message.payload.message !== undefined\n            && message.payload.message !== null // tslint:disable-line:no-null-keyword\n            && message.payload.message !== 'string') {\n            message.types.push('log-token-printf');\n            message.payload.tokenSupport = 'browser';\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/ConsoleInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\n\nexport const NOTIFY_CONSOLE_EVENT_OCCURED = 'notify|event|console';\n\nexport interface IConsoleEvent {\n    method: string;\n    arguments: any[]; // tslint:disable-line:no-any\n}\n\ninterface ProxyFunction { (): any; __glimpse_original: any; } // tslint:disable-line:no-any\n\nexport class ConsoleProxy implements IProxy {\n    // NOTE: this should probably be pulled from the inspector,\n    //       but that raising a dependency question and whether\n    //       one should know about the other. Was thinking about\n    //       adding a neutral party but thats overkill.\n    public methods = [\n        'assert',\n        'count',\n        'debug',\n        'dir',\n        'dirxml',\n        'error',\n        'group',\n        'groupCollapsed',\n        'groupEnd',\n        'info',\n        'log',\n        'profile',\n        'profileEnd',\n        'table',\n        'time',\n        'timeEnd',\n        'timeStamp',\n        'trace',\n        'warn'\n    ];\n\n    public isSupported() {\n        // IE9 and older throws an exception if we try and write a value to\n        // an undefined preoprty on console methods, so we test here if we\n        // can write to `console.log`, and if not return not supported\n        try {\n            // tslint:disable-next-line:no-any\n            (<any>console.log).__glimpse_enabled = true;\n            // tslint:disable-next-line:no-any\n            delete (<any>console.log).__glimpse_enabled;\n        } catch (e) {\n            return false;\n        }\n        return !!(window && typeof window.console !== 'undefined');\n    }\n\n    public init() {\n        this.methods.forEach((methodKey) => {\n            if (methodKey && console[methodKey] && !console[methodKey].__glimpse_original) {\n                console[methodKey] = (function (key) {\n                    const oldFunction = console[key];\n\n                    const newFunction = <ProxyFunction>function () {\n                        const args = Array.prototype.slice.call(arguments);\n\n                        tracing.publish(NOTIFY_CONSOLE_EVENT_OCCURED, { method: key, arguments: args });\n\n                        return oldFunction.apply(this, arguments);\n                    };\n\n                    oldFunction.__glimpse_proxy = newFunction;\n                    newFunction.__glimpse_original = oldFunction;\n\n                    return newFunction;\n                }(methodKey));\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/ConsoleProxy.ts","import { IInspector } from './IInspector';\nimport { IMessagePublisher } from '../MessagePublisher';\nimport { IProxyEvent } from '../tracing/IProxyEvent';\nimport tracing from '../tracing/Tracing';\nimport {\n  IPerformanceMarkEvent, EVENT_PERFORMANCE_MARK,\n  IPerformanceMeasureEvent, EVENT_PERFORMANCE_MEASURE\n} from '../tracing/proxies/PerformanceProxy';\nimport { addOffset } from '../common/MessageMixins';\nimport { getStackTrace, IStackFrame } from '../common/CallStackUtilities';\n\nexport class PerformanceInspector implements IInspector {\n\n    private messagePublisher: IMessagePublisher;\n\n    private markIdCache: { [ id: string ]: string } = {};\n\n    public init(messagePublisher: IMessagePublisher) {\n        this.messagePublisher = messagePublisher;\n        tracing.on(EVENT_PERFORMANCE_MARK, (data) => this.mark(data));\n        tracing.on(EVENT_PERFORMANCE_MEASURE, (data) => this.measure(data));\n    }\n\n    private mark(data: IProxyEvent) {\n        const eventData: IPerformanceMarkEvent = data.data;\n        const message = this.messagePublisher.createMessage('debug-timestamp', {\n            name: eventData.name\n        });\n\n        // Save the internal ID <> message ID correlation for lookup in measure\n        // events. We do this two stage caching level so that proxies don't need\n        // to know anything about the details of how message IDs work.\n        this.markIdCache[eventData.id] = message.id;\n\n        // Override the message offset directly. We override it manually instead\n        // of using `addOffset` because that method adjust the offset we pass to\n        // be relative to `performance.timing.requestStart - performance.timing.fetchStart`\n        // however the offsets we receive here are from performance.timing, so they\n        // are already relative to the proper time, and so shouldn't be adjusted\n        message.offset = eventData.startTime;\n\n        // If the mark is a built-in mark, then we skip collecting the stack trace\n        // because there is no actual stack trace associated with the mark\n        if (eventData.isBuiltIn) {\n            // Wrap the publish in a set timeout to make the asynchronicity\n            // of this method consistent across different event configurations\n            setTimeout(() => this.messagePublisher.publishMessage(message), 0);\n        } else {\n            // We create the message first, and add frames later, to ensure that\n            // the mark ID cache is filled and waiting when `performance.measure`\n            // is called, which may occur before the getStackTrace callback is\n            // called.\n            getStackTrace((frames: IStackFrame[]) => {\n                message.payload.frames = frames;\n                this.messagePublisher.publishMessage(message);\n            });\n        }\n    }\n\n    private measure(data: IProxyEvent) {\n        const eventData: IPerformanceMeasureEvent = data.data;\n\n        const startMarkMessageId = this.markIdCache[eventData.startMarkId];\n        const endMarkMessageId = this.markIdCache[eventData.endMarkId];\n\n        const message = this.messagePublisher.createMessage('debug-timestamp-measurement', {\n            correlationMessageIds: [ startMarkMessageId, endMarkMessageId ],\n            category: 'duration',\n            name: eventData.name\n        });\n        addOffset(data.offset, message);\n\n        this.messagePublisher.publishMessage(message);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/inspectors/PerformanceInspector.ts","import { IProxy } from '../IProxy';\nimport tracing from '../Tracing';\nimport performance from '../../common/PerformanceUtilities';\nimport { getGuid } from '../../common/GeneralUtilities';\n\n/**\n * This event indicates that `performance.mark()` was called.\n *\n * @property {string} id - a globally unique identifier\n * @property {string} name - The name of the mark\n * @property {string} startTime - The start time of the mark, as indicated by\n *      by a call to `performance.getEntriesByName(name)\n * @property {boolean} isBuiltIn - Whether or not this mark was explicitly\n *      created by the user, or if it was generated automatically by the browser\n */\nexport interface IPerformanceMarkEvent {\n    id: string;\n    name: string;\n    startTime: number;\n    isBuiltIn: boolean;\n}\nexport const EVENT_PERFORMANCE_MARK = 'invoke|post|performance.mark';\n\n/**\n * This event indicates that `performance.measure()` was called. The mark entries\n * supplied with this event are normalized. If a mark event is an \"implicit\" event,\n * e.g. it came from `performance.timing` instead of `performance.mark()`, then\n * a synthetic IPerformanceMarkEvent is created to represent it.\n *\n * @property {string} name - The name of the measure\n * @property {number} startTime - The time that measure was called\n * @property {object} startMark - The start mark event\n * @property {object} endMark - The end mark event\n */\nexport interface IPerformanceMeasureEvent {\n    name: string;\n    startMarkId: string;\n    endMarkId: string;\n}\nexport const EVENT_PERFORMANCE_MEASURE = 'invoke|post|performance.measure';\n\nlet measureIdCount = 1;\n\ninterface IPerformanceEntry {\n    name: string;\n    entryType: string;\n    startTime: number;\n    duration: number;\n}\n\nexport class PerformanceProxy implements IProxy {\n    private markIdCache: { [ name: string ]: string } = {};\n\n    private oldMeasure: (name: string, start: string, end: string) => void;\n\n    private getMarkId(name: string): string {\n\n        // Check if we have a cached mark entry, and if so, return it\n        if (this.markIdCache[name]) {\n            return this.markIdCache[name];\n        }\n\n        // If we got here, then that means there is not a cached mark entry,\n        // meaning we haven't seen the mark before. This can happen for two reasons:\n        // 1) The name is not a known mark name. Technically it shouldn't ever\n        //    get to this method, because `performance.measure` will throw first\n        // 2) The name is a built-in performance timing mark that the browser\n        //    generated on page load. These are stored in `performance.timing`\n\n        // This checks if we have a built-in `performance.timing` mark. If\n        // we do have a built in `performance.timing` mark, we create a mark\n        // message for this retroactively and publish a mark event. Note:\n        // if this built in mark was already referenced, it will be in the\n        // cache, meaning that this code will not be run twice for the same mark\n        if (performance.timing[name]) {\n\n            // We do a little hack here to get the `startTime` of the entry\n            // by measuring this mark against itself and getting the\n            // resulting performance entry\n            const tempMeasureName = `__glimpse_measure-${measureIdCount++}`;\n            this.oldMeasure.call(performance, tempMeasureName, name, name);\n            const tempMeasureEntry = this.getPerformanceEntryByName(tempMeasureName);\n\n            const eventData = this.initializeMark(name, tempMeasureEntry.startTime, true);\n\n            // We clear the measure entry now so we can keep the `performance.getEntries`\n            // history clean for users who want to query performance entries\n            performance.clearMeasures(tempMeasureName);\n\n            tracing.publish(EVENT_PERFORMANCE_MARK, eventData);\n            return eventData.id;\n        }\n\n        // If we got here, then it means the mark name is not valid. We _shouldn't_\n        // ever get here, because the browser's native `performance.measure` method\n        // will throw if the name is not know before this method is called.\n        return undefined;\n    }\n\n    private getPerformanceEntryByName(name: string): IPerformanceEntry {\n        return performance.getEntriesByName(name).pop();\n    }\n\n    private initializeMark(name: string, startTime: number, isBuiltIn: boolean): IPerformanceMarkEvent {\n        const id = getGuid();\n        const eventData: IPerformanceMarkEvent = {\n            id,\n            name,\n            startTime,\n            isBuiltIn\n        };\n\n        // We only need to store the newest ID in the cache because `performance.measure`\n        // always grabs the newest mark with a given name. For more info, see\n        // https://www.w3.org/TR/user-timing/#dom-performance-measure\n        this.markIdCache[name] = id;\n        return eventData;\n    }\n\n    private instrumentMark() {\n        const oldMark = performance.mark;\n        const self = this;\n        performance.mark = function mark(name, ...args) {\n            oldMark.call(this, name, ...args);\n            const performanceEntry = self.getPerformanceEntryByName(name);\n            const eventData = self.initializeMark(performanceEntry.name, performanceEntry.startTime, false);\n            tracing.publish(EVENT_PERFORMANCE_MARK, eventData);\n        };\n    }\n\n    private instrumentMeasure() {\n        this.oldMeasure = performance.measure;\n        const self = this;\n        performance.measure = function measure(name, startMark, endMark, ...args) {\n            self.oldMeasure.call(this, name, startMark, endMark, ...args);\n            const startMarkId = self.getMarkId(startMark);\n            const endMarkId = self.getMarkId(endMark);\n            if (startMarkId && endMarkId) {\n                const eventData: IPerformanceMeasureEvent = {\n                    name,\n                    startMarkId,\n                    endMarkId\n                };\n                tracing.publish(EVENT_PERFORMANCE_MEASURE, eventData);\n            }\n        };\n    }\n\n    public isSupported(): boolean {\n        return !!(performance && performance.getEntriesByName);\n    }\n\n    public init() {\n        if (performance.mark) {\n            this.instrumentMark();\n        }\n        if (performance.measure) {\n            this.instrumentMeasure();\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/proxies/PerformanceProxy.ts","import { IProxyClass } from './IProxy';\nimport { XHRProxy } from './proxies/XHRProxy';\nimport { FetchProxy } from './proxies/FetchProxy';\nimport { ResourceTimingProxy } from './proxies/ResourceTimingProxy';\nimport { NavigationTimingProxy } from './proxies/NavigationTimingProxy';\nimport { ConsoleProxy } from './proxies/ConsoleProxy';\nimport { PerformanceProxy } from './proxies/PerformanceProxy';\n\nconst proxies: { [proxyName: string]: IProxyClass } = {\n    XHRProxy,\n    FetchProxy,\n    ResourceTimingProxy,\n    NavigationTimingProxy,\n    ConsoleProxy,\n    PerformanceProxy\n};\n\nexport default function initializeProxies(): void {\n    for (const proxyName in proxies) {\n        if (proxies.hasOwnProperty(proxyName)) {\n            const proxy = new proxies[proxyName];\n\n            // Only initiate (attach) proxies if they are\n            // able to be used in the client.\n            if (proxy.isSupported()) {\n                proxy.init();\n            }\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tracing/initializeProxies.ts"],"sourceRoot":""}